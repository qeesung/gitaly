stages:
  - pre
  - build
  - test
  - analyze
  - qa

default:
  image: registry.gitlab.com/gitlab-org/gitlab-build-images:debian-${DEBIAN_VERSION}-ruby-${RUBY_VERSION}-golang-${GO_VERSION}-git-2.33-postgresql-11
  tags:
    - gitlab-org

variables:
  SAST_DISABLE_DIND: "true"
  SAST_DEFAULT_ANALYZERS: "gosec"
  DEBIAN_VERSION: "bullseye"
  POSTGRES_VERSION: "12.6-alpine"
  PGBOUNCER_VERSION: "1.16.1"

include:
  - template: Workflows/MergeRequest-Pipelines.gitlab-ci.yml
  - template: Security/License-Scanning.gitlab-ci.yml
  - template: Security/SAST.gitlab-ci.yml
  - template: Security/Dependency-Scanning.gitlab-ci.yml
  - template: Security/Secret-Detection.gitlab-ci.yml
  - project: 'gitlab-org/quality/pipeline-common'
    file:
      - '/ci/danger-review.yml'

.build:
  stage: build
  needs: []
  cache:
    - key:
        files:
          - .gitlab-ci.yml
          - ruby/Gemfile.lock
        prefix: ruby-${RUBY_VERSION}
      paths:
        - .ruby
    - key:
        files:
          - .gitlab-ci.yml
          - go.sum
        prefix: go-${GO_VERSION}
      paths:
        - .go/pkg/mod
        - _build/cache
  variables:
    BUNDLE_PATH: "${CI_PROJECT_DIR}/.ruby"
    GOPATH: "${CI_PROJECT_DIR}/.go"
  artifacts:
    expire_in: 1 hour
    paths:
      - .go/pkg/mod
      - .ruby
      # Ideally, we'd just cache the complete `_build` repository. Due to size
      # limitations that's not possible though, so we need to pick what's
      # important.
      - _build/bin
      - _build/deps
      - _build/testrepos
      - _build/tools
    exclude:
      # Exclude Git's tests, which are almost 40MB in size.
      - _build/deps/git-*/t
    reports:
      dotenv: build.env
  script:
    - go version
    # Build all dependencies required for our testing infrastructure such that
    # downstream jobs don't have to rebuild anything. Note that we're building
    # Git with `INSTALL_SYMLINKS=YesPlease INSTALL_STRIP=-s` to significantly
    # reduce the size of the installed Git distribution.
    - make -j$(nproc) build prepare-tests $(pwd)/_build/tools/gocover-cobertura $(pwd)/_build/tools/protoc WITH_BUNDLED_GIT=$(test "${GIT_VERSION}" = "default" && echo "YesPlease") GIT_APPEND_BUILD_OPTIONS="INSTALL_SYMLINKS=YesPlease INSTALL_STRIP=-s"
    - _support/test-boot . $(test "${GIT_VERSION}" = "default" && echo "--bundled-git")
  after_script: |
    # Write all relevant variables into the `build.env` file. These files are
    # then propagated to dependents so that they don't have to manually set
    # those variables again.
    for variable in GO_VERSION GIT_VERSION RUBY_VERSION BUNDLE_PATH GOPATH
    do
        echo "${variable}=${!variable}"
    done >build.env

.test:
  stage: test
  services:
    - postgres:${POSTGRES_VERSION}
  variables: &postgres_variables
    PGHOST: postgres
    PGPORT: 5432
    PGUSER: postgres
    POSTGRES_DB: praefect_test
    POSTGRES_HOST_AUTH_METHOD: trust
    TEST_REPORT: /tmp/go-tests-report.xml
  before_script: &postgres_before_script
    - while ! psql -h $PGHOST -U $PGUSER -c 'SELECT 1' > /dev/null; do echo "awaiting Postgres service to be ready..." && sleep 1 ; done && echo "Postgres service is ready!"
  script:
    # We run tests as unprivileged user so that file permissions are correctly honored.
    - setpriv --reuid=9999 --regid=9999 --clear-groups --no-new-privs env HOME=/dev/null make "${TEST_TARGET}" SKIP_RSPEC_BUILD=YesPlease WITH_BUNDLED_GIT=$(test "${GIT_VERSION}" = "default" && echo "YesPlease")
  artifacts:
    paths:
      - ruby/tmp/gitaly-rspec-test.log
    reports:
      junit: ${TEST_REPORT}
      coverage_report:
        coverage_format: cobertura
        path: _build/cover/cobertura.xml
    when: on_failure
    expire_in: 1 week

danger-review:
  stage: pre
  allow_failure: true
  variables:
    BUNDLE_GEMFILE: danger/Gemfile
  cache:
    key:
      files:
        - danger/Gemfile.lock
      prefix: debian-${DEBIAN_VERSION}-ruby-${RUBY_VERSION}
    paths:
      - .ruby
    policy: pull-push

# Default Go version with bundled Git.
build:go-1.17-git-bundled:
  extends: .build
  variables:
    GO_VERSION: "1.17"
    GIT_VERSION: "default"
    RUBY_VERSION: "2.7"

test:go-1.17-git-bundled:
  extends: .test
  needs: [ "build:go-1.17-git-bundled" ]
  parallel:
    matrix:
      - TEST_TARGET: [ test, test-with-proxies, test-with-praefect, cover, race-go ]
      - POSTGRES_VERSION: "11.14-alpine"
        TEST_TARGET: [ test, test-with-praefect ]

test:go-1.17-git-bundled-pgbouncer:
  extends: .test
  needs: [ "build:go-1.17-git-bundled" ]
  services:
    - postgres:${POSTGRES_VERSION}
    - name: bitnami/pgbouncer:${PGBOUNCER_VERSION}
      alias: pgbouncer
  variables:
    <<: *postgres_variables
    # The following variables are used by PgBouncer to connect to Postgres.
    POSTGRESQL_HOST: "${PGHOST}"
    # The image doesn't support setting `auth_user`, so we're cheating and use
    # "command line injection" here. In any case, `auth_user` is required so
    # that we can connect as a different user, but authenticate as the actual
    # PGUSER. We can fix this when
    # https://github.com/bitnami/bitnami-docker-pgbouncer/pull/22 lands.
    POSTGRESQL_PORT: "${PGPORT} auth_user=${PGUSER}"
    POSTGRESQL_USERNAME: "${PGUSER}"
    # These variables define how PgBouncer itself is configured
    PGBOUNCER_AUTH_TYPE: trust
    PGBOUNCER_DATABASE: "*"
    PGBOUNCER_IGNORE_STARTUP_PARAMETERS: extra_float_digits
    PGBOUNCER_POOL_MODE: transaction
    PGBOUNCER_MAX_DB_CONNECTIONS: 100
    # And these are finally used by Gitaly's tests.
    PGHOST_PGBOUNCER: pgbouncer
    PGPORT_PGBOUNCER: 6432
    # We need to enable per-build networking such that the PgBouncer service
    # can reach Postgres.
    FF_NETWORK_PER_BUILD: "true"
    TEST_TARGET: test-with-praefect
  before_script:
    - *postgres_before_script
    - while ! psql -h "${PGHOST_PGBOUNCER}" -p "${PGPORT_PGBOUNCER}" -U "${PGUSER}" -c 'SELECT 1' > /dev/null; do echo "awaiting PgBouncer service to be ready..." && sleep 1 ; done && echo "PgBouncer service is ready!"

test:go-1.17-git-bundled-smoke:
  extends: .test
  needs: [ "build:go-1.17-git-bundled" ]
  script:
    - ruby -rerb -e 'ERB.new(ARGF.read).run' _support/config.praefect.toml.ci-sql-test.erb > config.praefect.toml
    - ./_build/bin/praefect -config config.praefect.toml sql-ping
    - ./_build/bin/praefect -config config.praefect.toml sql-migrate

# This is our backwards-compatibility test with both the oldest supported
# version of Go and Git.
build:go-1.16-git-v2.33.0:
  extends: .build
  variables:
    GO_VERSION: "1.16"
    GIT_VERSION: "v2.33.0"
    RUBY_VERSION: "2.7"

test:go-1.16-git-v2.33.0:
  extends: .test
  needs: [ "build:go-1.16-git-v2.33.0" ]
  variables:
    TEST_TARGET: test

# These are our forwards-compatibility tests with the current `main` and `next`
# branch of the Git project. These job asserts that there are no upcoming
# regressions in the next Git release.
build:go-1.17-git-main:
  extends: .build
  needs: [ "build:go-1.17-git-main" ]
  variables:
    GO_VERSION: "1.17"
    GIT_VERSION: "main"
    RUBY_VERSION: "2.7"
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'

test:go-1.17-git-main:
  extends: .test
  needs: [ "build:go-1.17-git-main" ]
  parallel:
    matrix:
      - TEST_TARGET: [ test, test-with-proxies, test-with-praefect ]
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'

build:go-1.17-git-next:
  extends: .build
  needs: [ "build:go-1.17-git-next" ]
  variables:
    GO_VERSION: "1.17"
    GIT_VERSION: "next"
    RUBY_VERSION: "2.7"
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'

test:go-1.17-git-next:
  extends: .test
  needs: [ "build:go-1.17-git-next" ]
  parallel:
    matrix:
      - TEST_TARGET: [ test, test-with-proxies, test-with-praefect ]
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'

# This job only runs when we create new tags and stores all the Go binaries as
# artifacts for an extended amount of time.
build:binaries:
  stage: build
  only:
    - tags
  script:
    # Just in case we start running CI builds on other architectures in future
    - go version
    - make -j$(proc) build
    - cd _build && sha256sum bin/* | tee checksums.sha256.txt
  artifacts:
    paths:
    - _build/checksums.sha256.txt
    - _build/bin/
    name: "${CI_JOB_NAME}:go-${GO_VERSION}-git-${GIT_VERSION}"
    expire_in: 6 months
  parallel:
    matrix:
      - GO_VERSION: [ "1.16", "1.17" ]
        GIT_VERSION: [ "default" ]
        RUBY_VERSION: [ "2.7" ]

# Analysis-related jobs

verify:
  stage: analyze
  needs: [ "build:go-1.17-git-bundled" ]
  script:
    - make -j$(nproc) verify
  artifacts:
    paths:
      - _build/proto.diff
      - ruby/proto/gitaly/*
      - proto/go/gitalypb/*
    when: on_failure

dbschema:
  stage: analyze
  needs: [ "build:go-1.17-git-bundled" ]
  services:
    # The database version we use must match the version of `pg_dump` we have
    # available in the build image.
    - postgres:11.13-alpine
  variables:
    <<: *postgres_variables
  before_script:
    - *postgres_before_script
  script:
    - make dump-database-schema no-changes
  artifacts:
    paths:
      - _support/praefect-schema.sql
    when: on_failure

gosec-sast:
  stage: analyze
  needs: [ "build:go-1.17-git-bundled" ]
  variables:
    GOPATH: "/go"
  before_script:
    - apk add pkgconfig libgit2-dev gcc libc-dev
    - mv .go /go
  rules:
    - if: $SAST_DISABLED
      when: never
    - if: $CI_COMMIT_BRANCH && $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_MERGE_REQUEST_IID
    - if: $CI_COMMIT_TAG

license_scanning:
  stage: analyze
  needs: []
  before_script:
    - sudo apt-get update
    - sudo apt-get install -y libicu-dev libgit2-dev cmake
  rules:
    - if: $LICENSE_SCANNING_DISABLED
      when: never
    - if: $CI_COMMIT_BRANCH && $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_MERGE_REQUEST_IID
    - if: $CI_COMMIT_TAG
  variables:
    LICENSE_FINDER_CLI_OPTS: '--aggregate-paths=. ruby'

gemnasium-dependency_scanning:
  stage: analyze
  needs: []
  rules:
    - if: $DEPENDENCY_SCANNING_DISABLED
      when: never
    - if: $CI_COMMIT_BRANCH && $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_MERGE_REQUEST_IID
    - if: $CI_COMMIT_TAG

secret_detection:
  stage: analyze
  needs: []
  inherit:
    default: false
  rules:
    - if: $SECRET_DETECTION_DISABLED
      when: never
    - if: $CI_COMMIT_BRANCH && $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_MERGE_REQUEST_IID
    - if: $CI_COMMIT_TAG

trigger-qa:
  stage: qa
  trigger:
    project: gitlab-org/build/omnibus-gitlab-mirror
  variables:
    ALTERNATIVE_SOURCES: "true"
    GITALY_SERVER_VERSION: $CI_COMMIT_SHA
    GITALY_SERVER_ALTERNATIVE_REPO: $CI_PROJECT_URL
    ee: "true"
  rules:
    - if: $CI_MERGE_REQUEST_SOURCE_BRANCH_SHA != ""
      when: manual
      allow_failure: true
      variables:
        # Downstream pipeline does not fetch the merged result SHA.
        # Fix: https://gitlab.com/gitlab-org/omnibus-gitlab/-/issues/6482
        GITALY_SERVER_VERSION: $CI_MERGE_REQUEST_SOURCE_BRANCH_SHA
    - when: manual
      allow_failure: true
  needs: []

qa:nightly-praefect-migration-test:
  stage: qa
  trigger:
    project: gitlab-org/quality/praefect-migration-testing
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule"'
