// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package gitalypb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// PraefectInfoServiceClient is the client API for PraefectInfoService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PraefectInfoServiceClient interface {
	RepositoryReplicas(ctx context.Context, in *RepositoryReplicasRequest, opts ...grpc.CallOption) (*RepositoryReplicasResponse, error)
	// ConsistencyCheck will perform a consistency check on the requested
	// virtual storage backend. A stream of repository statuses will be sent
	// back indicating which repos are consistent with the primary and which ones
	// need repair.
	ConsistencyCheck(ctx context.Context, in *ConsistencyCheckRequest, opts ...grpc.CallOption) (PraefectInfoService_ConsistencyCheckClient, error)
	// DatalossCheck checks for outdated repository replicas.
	DatalossCheck(ctx context.Context, in *DatalossCheckRequest, opts ...grpc.CallOption) (*DatalossCheckResponse, error)
	// SetAuthoritativeStorage sets the authoritative storage for a repository on a given virtual storage.
	// This causes the current version of the repository on the authoritative storage to be considered the
	// latest and overwrite any other version on the virtual storage.
	SetAuthoritativeStorage(ctx context.Context, in *SetAuthoritativeStorageRequest, opts ...grpc.CallOption) (*SetAuthoritativeStorageResponse, error)
	// SetReplicationFactor assigns or unassigns host nodes from the repository to meet the desired replication factor.
	// SetReplicationFactor returns an error when trying to set a replication factor that exceeds the storage node count
	// in the virtual storage. An error is also returned when trying to set a replication factor below one. The primary node
	// won't be unassigned as it needs a copy of the repository to accept writes. Likewise, the primary is the first storage
	// that gets assigned when setting a replication factor for a repository. Assignments of unconfigured storages are ignored.
	// This might cause the actual replication factor to be higher than desired if the replication factor is set during an upgrade
	// from a Praefect node that does not yet know about a new node. As assignments of unconfigured storages are ignored, replication
	// factor of repositories assigned to a storage node removed from the cluster is effectively decreased.
	SetReplicationFactor(ctx context.Context, in *SetReplicationFactorRequest, opts ...grpc.CallOption) (*SetReplicationFactorResponse, error)
}

type praefectInfoServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPraefectInfoServiceClient(cc grpc.ClientConnInterface) PraefectInfoServiceClient {
	return &praefectInfoServiceClient{cc}
}

func (c *praefectInfoServiceClient) RepositoryReplicas(ctx context.Context, in *RepositoryReplicasRequest, opts ...grpc.CallOption) (*RepositoryReplicasResponse, error) {
	out := new(RepositoryReplicasResponse)
	err := c.cc.Invoke(ctx, "/gitaly.PraefectInfoService/RepositoryReplicas", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *praefectInfoServiceClient) ConsistencyCheck(ctx context.Context, in *ConsistencyCheckRequest, opts ...grpc.CallOption) (PraefectInfoService_ConsistencyCheckClient, error) {
	stream, err := c.cc.NewStream(ctx, &PraefectInfoService_ServiceDesc.Streams[0], "/gitaly.PraefectInfoService/ConsistencyCheck", opts...)
	if err != nil {
		return nil, err
	}
	x := &praefectInfoServiceConsistencyCheckClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type PraefectInfoService_ConsistencyCheckClient interface {
	Recv() (*ConsistencyCheckResponse, error)
	grpc.ClientStream
}

type praefectInfoServiceConsistencyCheckClient struct {
	grpc.ClientStream
}

func (x *praefectInfoServiceConsistencyCheckClient) Recv() (*ConsistencyCheckResponse, error) {
	m := new(ConsistencyCheckResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *praefectInfoServiceClient) DatalossCheck(ctx context.Context, in *DatalossCheckRequest, opts ...grpc.CallOption) (*DatalossCheckResponse, error) {
	out := new(DatalossCheckResponse)
	err := c.cc.Invoke(ctx, "/gitaly.PraefectInfoService/DatalossCheck", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *praefectInfoServiceClient) SetAuthoritativeStorage(ctx context.Context, in *SetAuthoritativeStorageRequest, opts ...grpc.CallOption) (*SetAuthoritativeStorageResponse, error) {
	out := new(SetAuthoritativeStorageResponse)
	err := c.cc.Invoke(ctx, "/gitaly.PraefectInfoService/SetAuthoritativeStorage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *praefectInfoServiceClient) SetReplicationFactor(ctx context.Context, in *SetReplicationFactorRequest, opts ...grpc.CallOption) (*SetReplicationFactorResponse, error) {
	out := new(SetReplicationFactorResponse)
	err := c.cc.Invoke(ctx, "/gitaly.PraefectInfoService/SetReplicationFactor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PraefectInfoServiceServer is the server API for PraefectInfoService service.
// All implementations must embed UnimplementedPraefectInfoServiceServer
// for forward compatibility
type PraefectInfoServiceServer interface {
	RepositoryReplicas(context.Context, *RepositoryReplicasRequest) (*RepositoryReplicasResponse, error)
	// ConsistencyCheck will perform a consistency check on the requested
	// virtual storage backend. A stream of repository statuses will be sent
	// back indicating which repos are consistent with the primary and which ones
	// need repair.
	ConsistencyCheck(*ConsistencyCheckRequest, PraefectInfoService_ConsistencyCheckServer) error
	// DatalossCheck checks for outdated repository replicas.
	DatalossCheck(context.Context, *DatalossCheckRequest) (*DatalossCheckResponse, error)
	// SetAuthoritativeStorage sets the authoritative storage for a repository on a given virtual storage.
	// This causes the current version of the repository on the authoritative storage to be considered the
	// latest and overwrite any other version on the virtual storage.
	SetAuthoritativeStorage(context.Context, *SetAuthoritativeStorageRequest) (*SetAuthoritativeStorageResponse, error)
	// SetReplicationFactor assigns or unassigns host nodes from the repository to meet the desired replication factor.
	// SetReplicationFactor returns an error when trying to set a replication factor that exceeds the storage node count
	// in the virtual storage. An error is also returned when trying to set a replication factor below one. The primary node
	// won't be unassigned as it needs a copy of the repository to accept writes. Likewise, the primary is the first storage
	// that gets assigned when setting a replication factor for a repository. Assignments of unconfigured storages are ignored.
	// This might cause the actual replication factor to be higher than desired if the replication factor is set during an upgrade
	// from a Praefect node that does not yet know about a new node. As assignments of unconfigured storages are ignored, replication
	// factor of repositories assigned to a storage node removed from the cluster is effectively decreased.
	SetReplicationFactor(context.Context, *SetReplicationFactorRequest) (*SetReplicationFactorResponse, error)
	mustEmbedUnimplementedPraefectInfoServiceServer()
}

// UnimplementedPraefectInfoServiceServer must be embedded to have forward compatible implementations.
type UnimplementedPraefectInfoServiceServer struct {
}

func (UnimplementedPraefectInfoServiceServer) RepositoryReplicas(context.Context, *RepositoryReplicasRequest) (*RepositoryReplicasResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RepositoryReplicas not implemented")
}
func (UnimplementedPraefectInfoServiceServer) ConsistencyCheck(*ConsistencyCheckRequest, PraefectInfoService_ConsistencyCheckServer) error {
	return status.Errorf(codes.Unimplemented, "method ConsistencyCheck not implemented")
}
func (UnimplementedPraefectInfoServiceServer) DatalossCheck(context.Context, *DatalossCheckRequest) (*DatalossCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DatalossCheck not implemented")
}
func (UnimplementedPraefectInfoServiceServer) SetAuthoritativeStorage(context.Context, *SetAuthoritativeStorageRequest) (*SetAuthoritativeStorageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetAuthoritativeStorage not implemented")
}
func (UnimplementedPraefectInfoServiceServer) SetReplicationFactor(context.Context, *SetReplicationFactorRequest) (*SetReplicationFactorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetReplicationFactor not implemented")
}
func (UnimplementedPraefectInfoServiceServer) mustEmbedUnimplementedPraefectInfoServiceServer() {}

// UnsafePraefectInfoServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PraefectInfoServiceServer will
// result in compilation errors.
type UnsafePraefectInfoServiceServer interface {
	mustEmbedUnimplementedPraefectInfoServiceServer()
}

func RegisterPraefectInfoServiceServer(s grpc.ServiceRegistrar, srv PraefectInfoServiceServer) {
	s.RegisterService(&PraefectInfoService_ServiceDesc, srv)
}

func _PraefectInfoService_RepositoryReplicas_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RepositoryReplicasRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PraefectInfoServiceServer).RepositoryReplicas(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitaly.PraefectInfoService/RepositoryReplicas",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PraefectInfoServiceServer).RepositoryReplicas(ctx, req.(*RepositoryReplicasRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PraefectInfoService_ConsistencyCheck_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ConsistencyCheckRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PraefectInfoServiceServer).ConsistencyCheck(m, &praefectInfoServiceConsistencyCheckServer{stream})
}

type PraefectInfoService_ConsistencyCheckServer interface {
	Send(*ConsistencyCheckResponse) error
	grpc.ServerStream
}

type praefectInfoServiceConsistencyCheckServer struct {
	grpc.ServerStream
}

func (x *praefectInfoServiceConsistencyCheckServer) Send(m *ConsistencyCheckResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _PraefectInfoService_DatalossCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DatalossCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PraefectInfoServiceServer).DatalossCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitaly.PraefectInfoService/DatalossCheck",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PraefectInfoServiceServer).DatalossCheck(ctx, req.(*DatalossCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PraefectInfoService_SetAuthoritativeStorage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetAuthoritativeStorageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PraefectInfoServiceServer).SetAuthoritativeStorage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitaly.PraefectInfoService/SetAuthoritativeStorage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PraefectInfoServiceServer).SetAuthoritativeStorage(ctx, req.(*SetAuthoritativeStorageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PraefectInfoService_SetReplicationFactor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetReplicationFactorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PraefectInfoServiceServer).SetReplicationFactor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitaly.PraefectInfoService/SetReplicationFactor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PraefectInfoServiceServer).SetReplicationFactor(ctx, req.(*SetReplicationFactorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PraefectInfoService_ServiceDesc is the grpc.ServiceDesc for PraefectInfoService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PraefectInfoService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "gitaly.PraefectInfoService",
	HandlerType: (*PraefectInfoServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RepositoryReplicas",
			Handler:    _PraefectInfoService_RepositoryReplicas_Handler,
		},
		{
			MethodName: "DatalossCheck",
			Handler:    _PraefectInfoService_DatalossCheck_Handler,
		},
		{
			MethodName: "SetAuthoritativeStorage",
			Handler:    _PraefectInfoService_SetAuthoritativeStorage_Handler,
		},
		{
			MethodName: "SetReplicationFactor",
			Handler:    _PraefectInfoService_SetReplicationFactor_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ConsistencyCheck",
			Handler:       _PraefectInfoService_ConsistencyCheck_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "praefect.proto",
}
