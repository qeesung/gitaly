// Code generated by protoc-gen-go. DO NOT EDIT.
// source: operations.proto

package gitalypb

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// CreateTreeError represents an error which happened when computing the
// cherry-pick.
type UserCherryPickResponse_CreateTreeError int32

const (
	// NONE denotes that no error occurred.
	UserCherryPickResponse_NONE UserCherryPickResponse_CreateTreeError = 0
	// EMPTY denotes that the cherry-pick would've resulted in an empty commit,
	// typically because it has already been applied to the target branch.
	UserCherryPickResponse_EMPTY UserCherryPickResponse_CreateTreeError = 1
	// CONFLICT denotes that the cherry-pick resulted in a conflict.
	UserCherryPickResponse_CONFLICT UserCherryPickResponse_CreateTreeError = 2
)

var UserCherryPickResponse_CreateTreeError_name = map[int32]string{
	0: "NONE",
	1: "EMPTY",
	2: "CONFLICT",
}

var UserCherryPickResponse_CreateTreeError_value = map[string]int32{
	"NONE":     0,
	"EMPTY":    1,
	"CONFLICT": 2,
}

func (x UserCherryPickResponse_CreateTreeError) String() string {
	return proto.EnumName(UserCherryPickResponse_CreateTreeError_name, int32(x))
}

func (UserCherryPickResponse_CreateTreeError) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1b4a5877375e491e, []int{18, 0}
}

// CreateTreeError represents an error which happened when computing the
// revert.
type UserRevertResponse_CreateTreeError int32

const (
	// NONE denotes that no error occurred.
	UserRevertResponse_NONE UserRevertResponse_CreateTreeError = 0
	// EMPTY denotes that the revert would've resulted in an empty commit,
	// typically because it has already been applied to the target branch.
	UserRevertResponse_EMPTY UserRevertResponse_CreateTreeError = 1
	// CONFLICT denotes that the revert resulted in a conflict.
	UserRevertResponse_CONFLICT UserRevertResponse_CreateTreeError = 2
)

var UserRevertResponse_CreateTreeError_name = map[int32]string{
	0: "NONE",
	1: "EMPTY",
	2: "CONFLICT",
}

var UserRevertResponse_CreateTreeError_value = map[string]int32{
	"NONE":     0,
	"EMPTY":    1,
	"CONFLICT": 2,
}

func (x UserRevertResponse_CreateTreeError) String() string {
	return proto.EnumName(UserRevertResponse_CreateTreeError_name, int32(x))
}

func (UserRevertResponse_CreateTreeError) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1b4a5877375e491e, []int{20, 0}
}

type UserCommitFilesActionHeader_ActionType int32

const (
	// CREATE creates a new file.
	UserCommitFilesActionHeader_CREATE UserCommitFilesActionHeader_ActionType = 0
	// CREATE_DIR creates a new directory.
	UserCommitFilesActionHeader_CREATE_DIR UserCommitFilesActionHeader_ActionType = 1
	// UPDATE updates an existing file.
	UserCommitFilesActionHeader_UPDATE UserCommitFilesActionHeader_ActionType = 2
	// MOVE moves an existing file to a new path.
	UserCommitFilesActionHeader_MOVE UserCommitFilesActionHeader_ActionType = 3
	// DELETE deletes an existing file.
	UserCommitFilesActionHeader_DELETE UserCommitFilesActionHeader_ActionType = 4
	// CHMOD changes the permissions of an existing file.
	UserCommitFilesActionHeader_CHMOD UserCommitFilesActionHeader_ActionType = 5
)

var UserCommitFilesActionHeader_ActionType_name = map[int32]string{
	0: "CREATE",
	1: "CREATE_DIR",
	2: "UPDATE",
	3: "MOVE",
	4: "DELETE",
	5: "CHMOD",
}

var UserCommitFilesActionHeader_ActionType_value = map[string]int32{
	"CREATE":     0,
	"CREATE_DIR": 1,
	"UPDATE":     2,
	"MOVE":       3,
	"DELETE":     4,
	"CHMOD":      5,
}

func (x UserCommitFilesActionHeader_ActionType) String() string {
	return proto.EnumName(UserCommitFilesActionHeader_ActionType_name, int32(x))
}

func (UserCommitFilesActionHeader_ActionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1b4a5877375e491e, []int{21, 0}
}

type UserCreateBranchRequest struct {
	Repository           *Repository `protobuf:"bytes,1,opt,name=repository,proto3" json:"repository,omitempty"`
	BranchName           []byte      `protobuf:"bytes,2,opt,name=branch_name,json=branchName,proto3" json:"branch_name,omitempty"`
	User                 *User       `protobuf:"bytes,3,opt,name=user,proto3" json:"user,omitempty"`
	StartPoint           []byte      `protobuf:"bytes,4,opt,name=start_point,json=startPoint,proto3" json:"start_point,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *UserCreateBranchRequest) Reset()         { *m = UserCreateBranchRequest{} }
func (m *UserCreateBranchRequest) String() string { return proto.CompactTextString(m) }
func (*UserCreateBranchRequest) ProtoMessage()    {}
func (*UserCreateBranchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b4a5877375e491e, []int{0}
}

func (m *UserCreateBranchRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserCreateBranchRequest.Unmarshal(m, b)
}
func (m *UserCreateBranchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserCreateBranchRequest.Marshal(b, m, deterministic)
}
func (m *UserCreateBranchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserCreateBranchRequest.Merge(m, src)
}
func (m *UserCreateBranchRequest) XXX_Size() int {
	return xxx_messageInfo_UserCreateBranchRequest.Size(m)
}
func (m *UserCreateBranchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UserCreateBranchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UserCreateBranchRequest proto.InternalMessageInfo

func (m *UserCreateBranchRequest) GetRepository() *Repository {
	if m != nil {
		return m.Repository
	}
	return nil
}

func (m *UserCreateBranchRequest) GetBranchName() []byte {
	if m != nil {
		return m.BranchName
	}
	return nil
}

func (m *UserCreateBranchRequest) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *UserCreateBranchRequest) GetStartPoint() []byte {
	if m != nil {
		return m.StartPoint
	}
	return nil
}

type UserCreateBranchResponse struct {
	Branch *Branch `protobuf:"bytes,1,opt,name=branch,proto3" json:"branch,omitempty"`
	// Error returned by the pre-receive hook. If no error was thrown,
	// it's the empty string ("")
	PreReceiveError      string   `protobuf:"bytes,2,opt,name=pre_receive_error,json=preReceiveError,proto3" json:"pre_receive_error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserCreateBranchResponse) Reset()         { *m = UserCreateBranchResponse{} }
func (m *UserCreateBranchResponse) String() string { return proto.CompactTextString(m) }
func (*UserCreateBranchResponse) ProtoMessage()    {}
func (*UserCreateBranchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b4a5877375e491e, []int{1}
}

func (m *UserCreateBranchResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserCreateBranchResponse.Unmarshal(m, b)
}
func (m *UserCreateBranchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserCreateBranchResponse.Marshal(b, m, deterministic)
}
func (m *UserCreateBranchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserCreateBranchResponse.Merge(m, src)
}
func (m *UserCreateBranchResponse) XXX_Size() int {
	return xxx_messageInfo_UserCreateBranchResponse.Size(m)
}
func (m *UserCreateBranchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UserCreateBranchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UserCreateBranchResponse proto.InternalMessageInfo

func (m *UserCreateBranchResponse) GetBranch() *Branch {
	if m != nil {
		return m.Branch
	}
	return nil
}

func (m *UserCreateBranchResponse) GetPreReceiveError() string {
	if m != nil {
		return m.PreReceiveError
	}
	return ""
}

type UserUpdateBranchRequest struct {
	Repository           *Repository `protobuf:"bytes,1,opt,name=repository,proto3" json:"repository,omitempty"`
	BranchName           []byte      `protobuf:"bytes,2,opt,name=branch_name,json=branchName,proto3" json:"branch_name,omitempty"`
	User                 *User       `protobuf:"bytes,3,opt,name=user,proto3" json:"user,omitempty"`
	Newrev               []byte      `protobuf:"bytes,4,opt,name=newrev,proto3" json:"newrev,omitempty"`
	Oldrev               []byte      `protobuf:"bytes,5,opt,name=oldrev,proto3" json:"oldrev,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *UserUpdateBranchRequest) Reset()         { *m = UserUpdateBranchRequest{} }
func (m *UserUpdateBranchRequest) String() string { return proto.CompactTextString(m) }
func (*UserUpdateBranchRequest) ProtoMessage()    {}
func (*UserUpdateBranchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b4a5877375e491e, []int{2}
}

func (m *UserUpdateBranchRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserUpdateBranchRequest.Unmarshal(m, b)
}
func (m *UserUpdateBranchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserUpdateBranchRequest.Marshal(b, m, deterministic)
}
func (m *UserUpdateBranchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserUpdateBranchRequest.Merge(m, src)
}
func (m *UserUpdateBranchRequest) XXX_Size() int {
	return xxx_messageInfo_UserUpdateBranchRequest.Size(m)
}
func (m *UserUpdateBranchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UserUpdateBranchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UserUpdateBranchRequest proto.InternalMessageInfo

func (m *UserUpdateBranchRequest) GetRepository() *Repository {
	if m != nil {
		return m.Repository
	}
	return nil
}

func (m *UserUpdateBranchRequest) GetBranchName() []byte {
	if m != nil {
		return m.BranchName
	}
	return nil
}

func (m *UserUpdateBranchRequest) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *UserUpdateBranchRequest) GetNewrev() []byte {
	if m != nil {
		return m.Newrev
	}
	return nil
}

func (m *UserUpdateBranchRequest) GetOldrev() []byte {
	if m != nil {
		return m.Oldrev
	}
	return nil
}

type UserUpdateBranchResponse struct {
	PreReceiveError      string   `protobuf:"bytes,1,opt,name=pre_receive_error,json=preReceiveError,proto3" json:"pre_receive_error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserUpdateBranchResponse) Reset()         { *m = UserUpdateBranchResponse{} }
func (m *UserUpdateBranchResponse) String() string { return proto.CompactTextString(m) }
func (*UserUpdateBranchResponse) ProtoMessage()    {}
func (*UserUpdateBranchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b4a5877375e491e, []int{3}
}

func (m *UserUpdateBranchResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserUpdateBranchResponse.Unmarshal(m, b)
}
func (m *UserUpdateBranchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserUpdateBranchResponse.Marshal(b, m, deterministic)
}
func (m *UserUpdateBranchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserUpdateBranchResponse.Merge(m, src)
}
func (m *UserUpdateBranchResponse) XXX_Size() int {
	return xxx_messageInfo_UserUpdateBranchResponse.Size(m)
}
func (m *UserUpdateBranchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UserUpdateBranchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UserUpdateBranchResponse proto.InternalMessageInfo

func (m *UserUpdateBranchResponse) GetPreReceiveError() string {
	if m != nil {
		return m.PreReceiveError
	}
	return ""
}

type UserDeleteBranchRequest struct {
	Repository           *Repository `protobuf:"bytes,1,opt,name=repository,proto3" json:"repository,omitempty"`
	BranchName           []byte      `protobuf:"bytes,2,opt,name=branch_name,json=branchName,proto3" json:"branch_name,omitempty"`
	User                 *User       `protobuf:"bytes,3,opt,name=user,proto3" json:"user,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *UserDeleteBranchRequest) Reset()         { *m = UserDeleteBranchRequest{} }
func (m *UserDeleteBranchRequest) String() string { return proto.CompactTextString(m) }
func (*UserDeleteBranchRequest) ProtoMessage()    {}
func (*UserDeleteBranchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b4a5877375e491e, []int{4}
}

func (m *UserDeleteBranchRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserDeleteBranchRequest.Unmarshal(m, b)
}
func (m *UserDeleteBranchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserDeleteBranchRequest.Marshal(b, m, deterministic)
}
func (m *UserDeleteBranchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserDeleteBranchRequest.Merge(m, src)
}
func (m *UserDeleteBranchRequest) XXX_Size() int {
	return xxx_messageInfo_UserDeleteBranchRequest.Size(m)
}
func (m *UserDeleteBranchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UserDeleteBranchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UserDeleteBranchRequest proto.InternalMessageInfo

func (m *UserDeleteBranchRequest) GetRepository() *Repository {
	if m != nil {
		return m.Repository
	}
	return nil
}

func (m *UserDeleteBranchRequest) GetBranchName() []byte {
	if m != nil {
		return m.BranchName
	}
	return nil
}

func (m *UserDeleteBranchRequest) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

type UserDeleteBranchResponse struct {
	PreReceiveError      string   `protobuf:"bytes,1,opt,name=pre_receive_error,json=preReceiveError,proto3" json:"pre_receive_error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserDeleteBranchResponse) Reset()         { *m = UserDeleteBranchResponse{} }
func (m *UserDeleteBranchResponse) String() string { return proto.CompactTextString(m) }
func (*UserDeleteBranchResponse) ProtoMessage()    {}
func (*UserDeleteBranchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b4a5877375e491e, []int{5}
}

func (m *UserDeleteBranchResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserDeleteBranchResponse.Unmarshal(m, b)
}
func (m *UserDeleteBranchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserDeleteBranchResponse.Marshal(b, m, deterministic)
}
func (m *UserDeleteBranchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserDeleteBranchResponse.Merge(m, src)
}
func (m *UserDeleteBranchResponse) XXX_Size() int {
	return xxx_messageInfo_UserDeleteBranchResponse.Size(m)
}
func (m *UserDeleteBranchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UserDeleteBranchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UserDeleteBranchResponse proto.InternalMessageInfo

func (m *UserDeleteBranchResponse) GetPreReceiveError() string {
	if m != nil {
		return m.PreReceiveError
	}
	return ""
}

type UserDeleteTagRequest struct {
	Repository           *Repository `protobuf:"bytes,1,opt,name=repository,proto3" json:"repository,omitempty"`
	TagName              []byte      `protobuf:"bytes,2,opt,name=tag_name,json=tagName,proto3" json:"tag_name,omitempty"`
	User                 *User       `protobuf:"bytes,3,opt,name=user,proto3" json:"user,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *UserDeleteTagRequest) Reset()         { *m = UserDeleteTagRequest{} }
func (m *UserDeleteTagRequest) String() string { return proto.CompactTextString(m) }
func (*UserDeleteTagRequest) ProtoMessage()    {}
func (*UserDeleteTagRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b4a5877375e491e, []int{6}
}

func (m *UserDeleteTagRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserDeleteTagRequest.Unmarshal(m, b)
}
func (m *UserDeleteTagRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserDeleteTagRequest.Marshal(b, m, deterministic)
}
func (m *UserDeleteTagRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserDeleteTagRequest.Merge(m, src)
}
func (m *UserDeleteTagRequest) XXX_Size() int {
	return xxx_messageInfo_UserDeleteTagRequest.Size(m)
}
func (m *UserDeleteTagRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UserDeleteTagRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UserDeleteTagRequest proto.InternalMessageInfo

func (m *UserDeleteTagRequest) GetRepository() *Repository {
	if m != nil {
		return m.Repository
	}
	return nil
}

func (m *UserDeleteTagRequest) GetTagName() []byte {
	if m != nil {
		return m.TagName
	}
	return nil
}

func (m *UserDeleteTagRequest) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

type UserDeleteTagResponse struct {
	PreReceiveError      string   `protobuf:"bytes,1,opt,name=pre_receive_error,json=preReceiveError,proto3" json:"pre_receive_error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserDeleteTagResponse) Reset()         { *m = UserDeleteTagResponse{} }
func (m *UserDeleteTagResponse) String() string { return proto.CompactTextString(m) }
func (*UserDeleteTagResponse) ProtoMessage()    {}
func (*UserDeleteTagResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b4a5877375e491e, []int{7}
}

func (m *UserDeleteTagResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserDeleteTagResponse.Unmarshal(m, b)
}
func (m *UserDeleteTagResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserDeleteTagResponse.Marshal(b, m, deterministic)
}
func (m *UserDeleteTagResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserDeleteTagResponse.Merge(m, src)
}
func (m *UserDeleteTagResponse) XXX_Size() int {
	return xxx_messageInfo_UserDeleteTagResponse.Size(m)
}
func (m *UserDeleteTagResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UserDeleteTagResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UserDeleteTagResponse proto.InternalMessageInfo

func (m *UserDeleteTagResponse) GetPreReceiveError() string {
	if m != nil {
		return m.PreReceiveError
	}
	return ""
}

type UserCreateTagRequest struct {
	// repository is the repository in which the tag shall be created.
	Repository *Repository `protobuf:"bytes,1,opt,name=repository,proto3" json:"repository,omitempty"`
	// tag_name is the name of the tag that shall be created.
	TagName []byte `protobuf:"bytes,2,opt,name=tag_name,json=tagName,proto3" json:"tag_name,omitempty"`
	// user is the user as which the tag shall be created.
	User *User `protobuf:"bytes,3,opt,name=user,proto3" json:"user,omitempty"`
	// target_revision is the revision which the tag should point to.
	TargetRevision []byte `protobuf:"bytes,4,opt,name=target_revision,json=targetRevision,proto3" json:"target_revision,omitempty"`
	// message is the message of the tag. If it is empty, a lightweight tag is
	// created. Otherwise, an annotated tag is created.
	Message []byte `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
	// timestamp is the optional timestamp to use for the created tag tags. If
	// it's not set, the current time will be used. It's only used if an
	// annotated tag is being created.
	Timestamp            *timestamp.Timestamp `protobuf:"bytes,7,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *UserCreateTagRequest) Reset()         { *m = UserCreateTagRequest{} }
func (m *UserCreateTagRequest) String() string { return proto.CompactTextString(m) }
func (*UserCreateTagRequest) ProtoMessage()    {}
func (*UserCreateTagRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b4a5877375e491e, []int{8}
}

func (m *UserCreateTagRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserCreateTagRequest.Unmarshal(m, b)
}
func (m *UserCreateTagRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserCreateTagRequest.Marshal(b, m, deterministic)
}
func (m *UserCreateTagRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserCreateTagRequest.Merge(m, src)
}
func (m *UserCreateTagRequest) XXX_Size() int {
	return xxx_messageInfo_UserCreateTagRequest.Size(m)
}
func (m *UserCreateTagRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UserCreateTagRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UserCreateTagRequest proto.InternalMessageInfo

func (m *UserCreateTagRequest) GetRepository() *Repository {
	if m != nil {
		return m.Repository
	}
	return nil
}

func (m *UserCreateTagRequest) GetTagName() []byte {
	if m != nil {
		return m.TagName
	}
	return nil
}

func (m *UserCreateTagRequest) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *UserCreateTagRequest) GetTargetRevision() []byte {
	if m != nil {
		return m.TargetRevision
	}
	return nil
}

func (m *UserCreateTagRequest) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *UserCreateTagRequest) GetTimestamp() *timestamp.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

type UserCreateTagResponse struct {
	// tag is the newly created tag.
	Tag *Tag `protobuf:"bytes,1,opt,name=tag,proto3" json:"tag,omitempty"`
	// exists denotes whether the tag has existed already.
	Exists bool `protobuf:"varint,2,opt,name=exists,proto3" json:"exists,omitempty"`
	// pre_receive_error contains an error message if updating the tag failed
	// because of a pre-receive error.
	PreReceiveError      string   `protobuf:"bytes,3,opt,name=pre_receive_error,json=preReceiveError,proto3" json:"pre_receive_error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserCreateTagResponse) Reset()         { *m = UserCreateTagResponse{} }
func (m *UserCreateTagResponse) String() string { return proto.CompactTextString(m) }
func (*UserCreateTagResponse) ProtoMessage()    {}
func (*UserCreateTagResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b4a5877375e491e, []int{9}
}

func (m *UserCreateTagResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserCreateTagResponse.Unmarshal(m, b)
}
func (m *UserCreateTagResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserCreateTagResponse.Marshal(b, m, deterministic)
}
func (m *UserCreateTagResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserCreateTagResponse.Merge(m, src)
}
func (m *UserCreateTagResponse) XXX_Size() int {
	return xxx_messageInfo_UserCreateTagResponse.Size(m)
}
func (m *UserCreateTagResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UserCreateTagResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UserCreateTagResponse proto.InternalMessageInfo

func (m *UserCreateTagResponse) GetTag() *Tag {
	if m != nil {
		return m.Tag
	}
	return nil
}

func (m *UserCreateTagResponse) GetExists() bool {
	if m != nil {
		return m.Exists
	}
	return false
}

func (m *UserCreateTagResponse) GetPreReceiveError() string {
	if m != nil {
		return m.PreReceiveError
	}
	return ""
}

type UserMergeBranchRequest struct {
	// repository is the repository to compute the merge for.
	Repository *Repository `protobuf:"bytes,1,opt,name=repository,proto3" json:"repository,omitempty"`
	// user is the user to compute the merge as. Its name and mail address are
	// used as author and committer of the merge.
	User *User `protobuf:"bytes,2,opt,name=user,proto3" json:"user,omitempty"`
	// commit_id is the object ID (hash) of the object that shall be merged into
	// the target branch.
	CommitId string `protobuf:"bytes,3,opt,name=commit_id,json=commitId,proto3" json:"commit_id,omitempty"`
	// branch is the branch into which the given commit shall be merged and whose
	// reference is going to be updated.
	Branch []byte `protobuf:"bytes,4,opt,name=branch,proto3" json:"branch,omitempty"`
	// message is the message to use for the merge commit.
	Message []byte `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
	// timestamp is the optional timestamp to use for the merge commit. If it's
	// not set, the current time will be used.
	Timestamp *timestamp.Timestamp `protobuf:"bytes,7,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// apply must only be set in the second message. Only if this second message
	// is sent and if apply is set to true will the branch be updated to point to
	// the merge commit.
	Apply                bool     `protobuf:"varint,6,opt,name=apply,proto3" json:"apply,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserMergeBranchRequest) Reset()         { *m = UserMergeBranchRequest{} }
func (m *UserMergeBranchRequest) String() string { return proto.CompactTextString(m) }
func (*UserMergeBranchRequest) ProtoMessage()    {}
func (*UserMergeBranchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b4a5877375e491e, []int{10}
}

func (m *UserMergeBranchRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserMergeBranchRequest.Unmarshal(m, b)
}
func (m *UserMergeBranchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserMergeBranchRequest.Marshal(b, m, deterministic)
}
func (m *UserMergeBranchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserMergeBranchRequest.Merge(m, src)
}
func (m *UserMergeBranchRequest) XXX_Size() int {
	return xxx_messageInfo_UserMergeBranchRequest.Size(m)
}
func (m *UserMergeBranchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UserMergeBranchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UserMergeBranchRequest proto.InternalMessageInfo

func (m *UserMergeBranchRequest) GetRepository() *Repository {
	if m != nil {
		return m.Repository
	}
	return nil
}

func (m *UserMergeBranchRequest) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *UserMergeBranchRequest) GetCommitId() string {
	if m != nil {
		return m.CommitId
	}
	return ""
}

func (m *UserMergeBranchRequest) GetBranch() []byte {
	if m != nil {
		return m.Branch
	}
	return nil
}

func (m *UserMergeBranchRequest) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *UserMergeBranchRequest) GetTimestamp() *timestamp.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *UserMergeBranchRequest) GetApply() bool {
	if m != nil {
		return m.Apply
	}
	return false
}

type UserMergeBranchResponse struct {
	// First message
	// The merge commit the branch will be updated to. The caller can still abort the merge.
	CommitId string `protobuf:"bytes,1,opt,name=commit_id,json=commitId,proto3" json:"commit_id,omitempty"`
	// Second message
	// If set, the merge has been applied to the branch.
	BranchUpdate         *OperationBranchUpdate `protobuf:"bytes,3,opt,name=branch_update,json=branchUpdate,proto3" json:"branch_update,omitempty"`
	PreReceiveError      string                 `protobuf:"bytes,4,opt,name=pre_receive_error,json=preReceiveError,proto3" json:"pre_receive_error,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *UserMergeBranchResponse) Reset()         { *m = UserMergeBranchResponse{} }
func (m *UserMergeBranchResponse) String() string { return proto.CompactTextString(m) }
func (*UserMergeBranchResponse) ProtoMessage()    {}
func (*UserMergeBranchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b4a5877375e491e, []int{11}
}

func (m *UserMergeBranchResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserMergeBranchResponse.Unmarshal(m, b)
}
func (m *UserMergeBranchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserMergeBranchResponse.Marshal(b, m, deterministic)
}
func (m *UserMergeBranchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserMergeBranchResponse.Merge(m, src)
}
func (m *UserMergeBranchResponse) XXX_Size() int {
	return xxx_messageInfo_UserMergeBranchResponse.Size(m)
}
func (m *UserMergeBranchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UserMergeBranchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UserMergeBranchResponse proto.InternalMessageInfo

func (m *UserMergeBranchResponse) GetCommitId() string {
	if m != nil {
		return m.CommitId
	}
	return ""
}

func (m *UserMergeBranchResponse) GetBranchUpdate() *OperationBranchUpdate {
	if m != nil {
		return m.BranchUpdate
	}
	return nil
}

func (m *UserMergeBranchResponse) GetPreReceiveError() string {
	if m != nil {
		return m.PreReceiveError
	}
	return ""
}

type UserMergeToRefRequest struct {
	// repository is the repository in which the merge shall be computed.
	Repository *Repository `protobuf:"bytes,1,opt,name=repository,proto3" json:"repository,omitempty"`
	// user is the user as which the merge commit shall be created.
	User *User `protobuf:"bytes,2,opt,name=user,proto3" json:"user,omitempty"`
	// source_sha is the object ID of the second parent of the computed merge.
	SourceSha string `protobuf:"bytes,3,opt,name=source_sha,json=sourceSha,proto3" json:"source_sha,omitempty"`
	// branch contains the name of the branch which should be used as the first
	// parent of the computed merge. It is deprecated in favor of
	// `first_parent_ref` and will be ignored in case it is set.
	Branch []byte `protobuf:"bytes,4,opt,name=branch,proto3" json:"branch,omitempty"`
	// target_ref contains the fully qualified reference which should be updated
	// with the computed merge commit.
	TargetRef []byte `protobuf:"bytes,5,opt,name=target_ref,json=targetRef,proto3" json:"target_ref,omitempty"`
	// message is the message to use for the merge commit.
	Message []byte `protobuf:"bytes,6,opt,name=message,proto3" json:"message,omitempty"`
	// first_parent_ref is the name of the reference which should be used as the
	// first parent of the computed merge. Overrides `branch`.
	FirstParentRef []byte `protobuf:"bytes,7,opt,name=first_parent_ref,json=firstParentRef,proto3" json:"first_parent_ref,omitempty"`
	// Allow conflicts to occur. Any conflict markers will be part of the merge commit.
	// Only text conflicts are handled, tree-based conflicts are not supported.
	AllowConflicts bool `protobuf:"varint,8,opt,name=allow_conflicts,json=allowConflicts,proto3" json:"allow_conflicts,omitempty"`
	// timestamp is the optional timestamp to use for the merge commit. If it's
	// not set, the current time will be used.
	Timestamp            *timestamp.Timestamp `protobuf:"bytes,9,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *UserMergeToRefRequest) Reset()         { *m = UserMergeToRefRequest{} }
func (m *UserMergeToRefRequest) String() string { return proto.CompactTextString(m) }
func (*UserMergeToRefRequest) ProtoMessage()    {}
func (*UserMergeToRefRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b4a5877375e491e, []int{12}
}

func (m *UserMergeToRefRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserMergeToRefRequest.Unmarshal(m, b)
}
func (m *UserMergeToRefRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserMergeToRefRequest.Marshal(b, m, deterministic)
}
func (m *UserMergeToRefRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserMergeToRefRequest.Merge(m, src)
}
func (m *UserMergeToRefRequest) XXX_Size() int {
	return xxx_messageInfo_UserMergeToRefRequest.Size(m)
}
func (m *UserMergeToRefRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UserMergeToRefRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UserMergeToRefRequest proto.InternalMessageInfo

func (m *UserMergeToRefRequest) GetRepository() *Repository {
	if m != nil {
		return m.Repository
	}
	return nil
}

func (m *UserMergeToRefRequest) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *UserMergeToRefRequest) GetSourceSha() string {
	if m != nil {
		return m.SourceSha
	}
	return ""
}

func (m *UserMergeToRefRequest) GetBranch() []byte {
	if m != nil {
		return m.Branch
	}
	return nil
}

func (m *UserMergeToRefRequest) GetTargetRef() []byte {
	if m != nil {
		return m.TargetRef
	}
	return nil
}

func (m *UserMergeToRefRequest) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *UserMergeToRefRequest) GetFirstParentRef() []byte {
	if m != nil {
		return m.FirstParentRef
	}
	return nil
}

func (m *UserMergeToRefRequest) GetAllowConflicts() bool {
	if m != nil {
		return m.AllowConflicts
	}
	return false
}

func (m *UserMergeToRefRequest) GetTimestamp() *timestamp.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

type UserMergeToRefResponse struct {
	// commit_id is the object ID of the computed merge commit.
	CommitId string `protobuf:"bytes,1,opt,name=commit_id,json=commitId,proto3" json:"commit_id,omitempty"`
	// pre_receive_error contains an error message if the merge failed.
	PreReceiveError      string   `protobuf:"bytes,2,opt,name=pre_receive_error,json=preReceiveError,proto3" json:"pre_receive_error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserMergeToRefResponse) Reset()         { *m = UserMergeToRefResponse{} }
func (m *UserMergeToRefResponse) String() string { return proto.CompactTextString(m) }
func (*UserMergeToRefResponse) ProtoMessage()    {}
func (*UserMergeToRefResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b4a5877375e491e, []int{13}
}

func (m *UserMergeToRefResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserMergeToRefResponse.Unmarshal(m, b)
}
func (m *UserMergeToRefResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserMergeToRefResponse.Marshal(b, m, deterministic)
}
func (m *UserMergeToRefResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserMergeToRefResponse.Merge(m, src)
}
func (m *UserMergeToRefResponse) XXX_Size() int {
	return xxx_messageInfo_UserMergeToRefResponse.Size(m)
}
func (m *UserMergeToRefResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UserMergeToRefResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UserMergeToRefResponse proto.InternalMessageInfo

func (m *UserMergeToRefResponse) GetCommitId() string {
	if m != nil {
		return m.CommitId
	}
	return ""
}

func (m *UserMergeToRefResponse) GetPreReceiveError() string {
	if m != nil {
		return m.PreReceiveError
	}
	return ""
}

// OperationBranchUpdate contains the details of a branch update.
type OperationBranchUpdate struct {
	// commit_id is set to the OID of the created commit if a branch was created or updated.
	CommitId string `protobuf:"bytes,1,opt,name=commit_id,json=commitId,proto3" json:"commit_id,omitempty"`
	// repo_created indicates whether the branch created was the first one in the repository.
	// Used for cache invalidation in GitLab.
	RepoCreated bool `protobuf:"varint,2,opt,name=repo_created,json=repoCreated,proto3" json:"repo_created,omitempty"`
	// branch_created indicates whether the branch already existed in the repository
	// and was updated or whether it was created. Used for cache invalidation in GitLab.
	BranchCreated        bool     `protobuf:"varint,3,opt,name=branch_created,json=branchCreated,proto3" json:"branch_created,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OperationBranchUpdate) Reset()         { *m = OperationBranchUpdate{} }
func (m *OperationBranchUpdate) String() string { return proto.CompactTextString(m) }
func (*OperationBranchUpdate) ProtoMessage()    {}
func (*OperationBranchUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b4a5877375e491e, []int{14}
}

func (m *OperationBranchUpdate) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OperationBranchUpdate.Unmarshal(m, b)
}
func (m *OperationBranchUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OperationBranchUpdate.Marshal(b, m, deterministic)
}
func (m *OperationBranchUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperationBranchUpdate.Merge(m, src)
}
func (m *OperationBranchUpdate) XXX_Size() int {
	return xxx_messageInfo_OperationBranchUpdate.Size(m)
}
func (m *OperationBranchUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_OperationBranchUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_OperationBranchUpdate proto.InternalMessageInfo

func (m *OperationBranchUpdate) GetCommitId() string {
	if m != nil {
		return m.CommitId
	}
	return ""
}

func (m *OperationBranchUpdate) GetRepoCreated() bool {
	if m != nil {
		return m.RepoCreated
	}
	return false
}

func (m *OperationBranchUpdate) GetBranchCreated() bool {
	if m != nil {
		return m.BranchCreated
	}
	return false
}

// UserFFBranchRequest contains parameters for the UserFFBranch RPC.
type UserFFBranchRequest struct {
	// repository is the repository for which to perform the fast-forward merge.
	Repository *Repository `protobuf:"bytes,1,opt,name=repository,proto3" json:"repository,omitempty"`
	// user is the user which to perform the fast-forward merge as. This is used
	// for authorization checks.
	User *User `protobuf:"bytes,2,opt,name=user,proto3" json:"user,omitempty"`
	// commit_id is the commit ID to update the branch to.
	CommitId string `protobuf:"bytes,3,opt,name=commit_id,json=commitId,proto3" json:"commit_id,omitempty"`
	// branch is the name of the branch that shall be update. This must be the
	// branch name only and not a fully qualified reference, e.g. "master"
	// instead of "refs/heads/master".
	Branch               []byte   `protobuf:"bytes,4,opt,name=branch,proto3" json:"branch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserFFBranchRequest) Reset()         { *m = UserFFBranchRequest{} }
func (m *UserFFBranchRequest) String() string { return proto.CompactTextString(m) }
func (*UserFFBranchRequest) ProtoMessage()    {}
func (*UserFFBranchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b4a5877375e491e, []int{15}
}

func (m *UserFFBranchRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserFFBranchRequest.Unmarshal(m, b)
}
func (m *UserFFBranchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserFFBranchRequest.Marshal(b, m, deterministic)
}
func (m *UserFFBranchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserFFBranchRequest.Merge(m, src)
}
func (m *UserFFBranchRequest) XXX_Size() int {
	return xxx_messageInfo_UserFFBranchRequest.Size(m)
}
func (m *UserFFBranchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UserFFBranchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UserFFBranchRequest proto.InternalMessageInfo

func (m *UserFFBranchRequest) GetRepository() *Repository {
	if m != nil {
		return m.Repository
	}
	return nil
}

func (m *UserFFBranchRequest) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *UserFFBranchRequest) GetCommitId() string {
	if m != nil {
		return m.CommitId
	}
	return ""
}

func (m *UserFFBranchRequest) GetBranch() []byte {
	if m != nil {
		return m.Branch
	}
	return nil
}

type UserFFBranchResponse struct {
	BranchUpdate         *OperationBranchUpdate `protobuf:"bytes,1,opt,name=branch_update,json=branchUpdate,proto3" json:"branch_update,omitempty"`
	PreReceiveError      string                 `protobuf:"bytes,2,opt,name=pre_receive_error,json=preReceiveError,proto3" json:"pre_receive_error,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *UserFFBranchResponse) Reset()         { *m = UserFFBranchResponse{} }
func (m *UserFFBranchResponse) String() string { return proto.CompactTextString(m) }
func (*UserFFBranchResponse) ProtoMessage()    {}
func (*UserFFBranchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b4a5877375e491e, []int{16}
}

func (m *UserFFBranchResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserFFBranchResponse.Unmarshal(m, b)
}
func (m *UserFFBranchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserFFBranchResponse.Marshal(b, m, deterministic)
}
func (m *UserFFBranchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserFFBranchResponse.Merge(m, src)
}
func (m *UserFFBranchResponse) XXX_Size() int {
	return xxx_messageInfo_UserFFBranchResponse.Size(m)
}
func (m *UserFFBranchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UserFFBranchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UserFFBranchResponse proto.InternalMessageInfo

func (m *UserFFBranchResponse) GetBranchUpdate() *OperationBranchUpdate {
	if m != nil {
		return m.BranchUpdate
	}
	return nil
}

func (m *UserFFBranchResponse) GetPreReceiveError() string {
	if m != nil {
		return m.PreReceiveError
	}
	return ""
}

type UserCherryPickRequest struct {
	// repository is the repository into which the cherry-pick shall be
	// performed.
	Repository *Repository `protobuf:"bytes,1,opt,name=repository,proto3" json:"repository,omitempty"`
	// user is the user to perform the cherry-pick as. This is used for
	// authorization checks and as the committer of the computed cherry-pick.
	User *User `protobuf:"bytes,2,opt,name=user,proto3" json:"user,omitempty"`
	// commit is the commit to cherry-pick onto the given branch.
	Commit *GitCommit `protobuf:"bytes,3,opt,name=commit,proto3" json:"commit,omitempty"`
	// branch_name is the name of the branch onto which the cherry-pick shall be
	// executed.
	BranchName []byte `protobuf:"bytes,4,opt,name=branch_name,json=branchName,proto3" json:"branch_name,omitempty"`
	// message is the message to use for the cherry-picked commit.
	Message []byte `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
	// start_branch_name is is used in case the branch_name branch does not
	// exist. In that case, it will be created from the start_branch_name.
	StartBranchName []byte `protobuf:"bytes,6,opt,name=start_branch_name,json=startBranchName,proto3" json:"start_branch_name,omitempty"`
	// start_repository is used in case the branch_name branch does not exist. In
	// that case, it will be created from start_branch_name in the
	// start_repository.
	StartRepository *Repository `protobuf:"bytes,7,opt,name=start_repository,json=startRepository,proto3" json:"start_repository,omitempty"`
	// dry_run will compute the cherry-pick, but not update the target branch.
	DryRun bool `protobuf:"varint,8,opt,name=dry_run,json=dryRun,proto3" json:"dry_run,omitempty"`
	// timestamp is the optional timestamp to use for the created cherry-picked
	// commit's committer date. If it's not set, the current time will be used.
	Timestamp            *timestamp.Timestamp `protobuf:"bytes,9,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *UserCherryPickRequest) Reset()         { *m = UserCherryPickRequest{} }
func (m *UserCherryPickRequest) String() string { return proto.CompactTextString(m) }
func (*UserCherryPickRequest) ProtoMessage()    {}
func (*UserCherryPickRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b4a5877375e491e, []int{17}
}

func (m *UserCherryPickRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserCherryPickRequest.Unmarshal(m, b)
}
func (m *UserCherryPickRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserCherryPickRequest.Marshal(b, m, deterministic)
}
func (m *UserCherryPickRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserCherryPickRequest.Merge(m, src)
}
func (m *UserCherryPickRequest) XXX_Size() int {
	return xxx_messageInfo_UserCherryPickRequest.Size(m)
}
func (m *UserCherryPickRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UserCherryPickRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UserCherryPickRequest proto.InternalMessageInfo

func (m *UserCherryPickRequest) GetRepository() *Repository {
	if m != nil {
		return m.Repository
	}
	return nil
}

func (m *UserCherryPickRequest) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *UserCherryPickRequest) GetCommit() *GitCommit {
	if m != nil {
		return m.Commit
	}
	return nil
}

func (m *UserCherryPickRequest) GetBranchName() []byte {
	if m != nil {
		return m.BranchName
	}
	return nil
}

func (m *UserCherryPickRequest) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *UserCherryPickRequest) GetStartBranchName() []byte {
	if m != nil {
		return m.StartBranchName
	}
	return nil
}

func (m *UserCherryPickRequest) GetStartRepository() *Repository {
	if m != nil {
		return m.StartRepository
	}
	return nil
}

func (m *UserCherryPickRequest) GetDryRun() bool {
	if m != nil {
		return m.DryRun
	}
	return false
}

func (m *UserCherryPickRequest) GetTimestamp() *timestamp.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

type UserCherryPickResponse struct {
	// branch_update represents details about the updated branch.
	BranchUpdate *OperationBranchUpdate `protobuf:"bytes,1,opt,name=branch_update,json=branchUpdate,proto3" json:"branch_update,omitempty"`
	// create_tree_error contains the error message if creation of the tree
	// failed.
	CreateTreeError string `protobuf:"bytes,2,opt,name=create_tree_error,json=createTreeError,proto3" json:"create_tree_error,omitempty"`
	// commit_error contains the error message if updating the reference failed.
	CommitError string `protobuf:"bytes,3,opt,name=commit_error,json=commitError,proto3" json:"commit_error,omitempty"`
	// pre_receive_error contains the error message if the pre-receive hook
	// failed.
	PreReceiveError string `protobuf:"bytes,4,opt,name=pre_receive_error,json=preReceiveError,proto3" json:"pre_receive_error,omitempty"`
	// create_tree_error_code contains the error code if creation of the tree
	// failed.
	CreateTreeErrorCode  UserCherryPickResponse_CreateTreeError `protobuf:"varint,5,opt,name=create_tree_error_code,json=createTreeErrorCode,proto3,enum=gitaly.UserCherryPickResponse_CreateTreeError" json:"create_tree_error_code,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                               `json:"-"`
	XXX_unrecognized     []byte                                 `json:"-"`
	XXX_sizecache        int32                                  `json:"-"`
}

func (m *UserCherryPickResponse) Reset()         { *m = UserCherryPickResponse{} }
func (m *UserCherryPickResponse) String() string { return proto.CompactTextString(m) }
func (*UserCherryPickResponse) ProtoMessage()    {}
func (*UserCherryPickResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b4a5877375e491e, []int{18}
}

func (m *UserCherryPickResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserCherryPickResponse.Unmarshal(m, b)
}
func (m *UserCherryPickResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserCherryPickResponse.Marshal(b, m, deterministic)
}
func (m *UserCherryPickResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserCherryPickResponse.Merge(m, src)
}
func (m *UserCherryPickResponse) XXX_Size() int {
	return xxx_messageInfo_UserCherryPickResponse.Size(m)
}
func (m *UserCherryPickResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UserCherryPickResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UserCherryPickResponse proto.InternalMessageInfo

func (m *UserCherryPickResponse) GetBranchUpdate() *OperationBranchUpdate {
	if m != nil {
		return m.BranchUpdate
	}
	return nil
}

func (m *UserCherryPickResponse) GetCreateTreeError() string {
	if m != nil {
		return m.CreateTreeError
	}
	return ""
}

func (m *UserCherryPickResponse) GetCommitError() string {
	if m != nil {
		return m.CommitError
	}
	return ""
}

func (m *UserCherryPickResponse) GetPreReceiveError() string {
	if m != nil {
		return m.PreReceiveError
	}
	return ""
}

func (m *UserCherryPickResponse) GetCreateTreeErrorCode() UserCherryPickResponse_CreateTreeError {
	if m != nil {
		return m.CreateTreeErrorCode
	}
	return UserCherryPickResponse_NONE
}

type UserRevertRequest struct {
	// repository is the repository in which the revert shall be applied.
	Repository *Repository `protobuf:"bytes,1,opt,name=repository,proto3" json:"repository,omitempty"`
	// user is the user to perform the revert as. This is used both for
	// authorization and as author/committer for the revert commit.
	User *User `protobuf:"bytes,2,opt,name=user,proto3" json:"user,omitempty"`
	// commit iis the commit to revert.
	Commit *GitCommit `protobuf:"bytes,3,opt,name=commit,proto3" json:"commit,omitempty"`
	// branch_name is the name of the branch onto which the reverted commit shall
	// be committed.
	BranchName []byte `protobuf:"bytes,4,opt,name=branch_name,json=branchName,proto3" json:"branch_name,omitempty"`
	// message is the message to use for the revert commit.
	Message []byte `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
	// start_branch_name is is used in case the branch_name branch does not
	// exist. In that case, it will be created from the start_branch_name.
	StartBranchName []byte `protobuf:"bytes,6,opt,name=start_branch_name,json=startBranchName,proto3" json:"start_branch_name,omitempty"`
	// start_repository is used in case the branch_name branch does not exist. In
	// that case, it will be created from start_branch_name in the
	// start_repository.
	StartRepository *Repository `protobuf:"bytes,7,opt,name=start_repository,json=startRepository,proto3" json:"start_repository,omitempty"`
	// dry_run  will compute the revert, but not update the target branch.
	DryRun bool `protobuf:"varint,8,opt,name=dry_run,json=dryRun,proto3" json:"dry_run,omitempty"`
	// timestamp is the optional timestamp to use for the created cherry-picked
	// commit's committer date. If it's not set, the current time will be used.
	Timestamp            *timestamp.Timestamp `protobuf:"bytes,9,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *UserRevertRequest) Reset()         { *m = UserRevertRequest{} }
func (m *UserRevertRequest) String() string { return proto.CompactTextString(m) }
func (*UserRevertRequest) ProtoMessage()    {}
func (*UserRevertRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b4a5877375e491e, []int{19}
}

func (m *UserRevertRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserRevertRequest.Unmarshal(m, b)
}
func (m *UserRevertRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserRevertRequest.Marshal(b, m, deterministic)
}
func (m *UserRevertRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserRevertRequest.Merge(m, src)
}
func (m *UserRevertRequest) XXX_Size() int {
	return xxx_messageInfo_UserRevertRequest.Size(m)
}
func (m *UserRevertRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UserRevertRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UserRevertRequest proto.InternalMessageInfo

func (m *UserRevertRequest) GetRepository() *Repository {
	if m != nil {
		return m.Repository
	}
	return nil
}

func (m *UserRevertRequest) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *UserRevertRequest) GetCommit() *GitCommit {
	if m != nil {
		return m.Commit
	}
	return nil
}

func (m *UserRevertRequest) GetBranchName() []byte {
	if m != nil {
		return m.BranchName
	}
	return nil
}

func (m *UserRevertRequest) GetMessage() []byte {
	if m != nil {
		return m.Message
	}
	return nil
}

func (m *UserRevertRequest) GetStartBranchName() []byte {
	if m != nil {
		return m.StartBranchName
	}
	return nil
}

func (m *UserRevertRequest) GetStartRepository() *Repository {
	if m != nil {
		return m.StartRepository
	}
	return nil
}

func (m *UserRevertRequest) GetDryRun() bool {
	if m != nil {
		return m.DryRun
	}
	return false
}

func (m *UserRevertRequest) GetTimestamp() *timestamp.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

type UserRevertResponse struct {
	// branch_update represents details about the updated branch.
	BranchUpdate *OperationBranchUpdate `protobuf:"bytes,1,opt,name=branch_update,json=branchUpdate,proto3" json:"branch_update,omitempty"`
	// create_tree_error contains the error message if creation of the tree
	// failed.
	CreateTreeError string `protobuf:"bytes,2,opt,name=create_tree_error,json=createTreeError,proto3" json:"create_tree_error,omitempty"`
	// commit_error contains the error message if updating the reference failed.
	CommitError string `protobuf:"bytes,3,opt,name=commit_error,json=commitError,proto3" json:"commit_error,omitempty"`
	// pre_receive_error contains the error message if the pre-receive hook
	// failed.
	PreReceiveError string `protobuf:"bytes,4,opt,name=pre_receive_error,json=preReceiveError,proto3" json:"pre_receive_error,omitempty"`
	// create_tree_error_code contains the error code if creation of the tree
	// failed.
	CreateTreeErrorCode  UserRevertResponse_CreateTreeError `protobuf:"varint,5,opt,name=create_tree_error_code,json=createTreeErrorCode,proto3,enum=gitaly.UserRevertResponse_CreateTreeError" json:"create_tree_error_code,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                           `json:"-"`
	XXX_unrecognized     []byte                             `json:"-"`
	XXX_sizecache        int32                              `json:"-"`
}

func (m *UserRevertResponse) Reset()         { *m = UserRevertResponse{} }
func (m *UserRevertResponse) String() string { return proto.CompactTextString(m) }
func (*UserRevertResponse) ProtoMessage()    {}
func (*UserRevertResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b4a5877375e491e, []int{20}
}

func (m *UserRevertResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserRevertResponse.Unmarshal(m, b)
}
func (m *UserRevertResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserRevertResponse.Marshal(b, m, deterministic)
}
func (m *UserRevertResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserRevertResponse.Merge(m, src)
}
func (m *UserRevertResponse) XXX_Size() int {
	return xxx_messageInfo_UserRevertResponse.Size(m)
}
func (m *UserRevertResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UserRevertResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UserRevertResponse proto.InternalMessageInfo

func (m *UserRevertResponse) GetBranchUpdate() *OperationBranchUpdate {
	if m != nil {
		return m.BranchUpdate
	}
	return nil
}

func (m *UserRevertResponse) GetCreateTreeError() string {
	if m != nil {
		return m.CreateTreeError
	}
	return ""
}

func (m *UserRevertResponse) GetCommitError() string {
	if m != nil {
		return m.CommitError
	}
	return ""
}

func (m *UserRevertResponse) GetPreReceiveError() string {
	if m != nil {
		return m.PreReceiveError
	}
	return ""
}

func (m *UserRevertResponse) GetCreateTreeErrorCode() UserRevertResponse_CreateTreeError {
	if m != nil {
		return m.CreateTreeErrorCode
	}
	return UserRevertResponse_NONE
}

// UserCommitFilesActionHeader contains the details of the action to be performed.
type UserCommitFilesActionHeader struct {
	// action is the type of the action taken to build a commit. Not all fields are
	// used for all of the actions.
	Action UserCommitFilesActionHeader_ActionType `protobuf:"varint,1,opt,name=action,proto3,enum=gitaly.UserCommitFilesActionHeader_ActionType" json:"action,omitempty"`
	// file_path refers to the file or directory being modified. The meaning differs for each
	// action:
	//   1. CREATE: path of the file to create
	//   2. CREATE_DIR: path of the directory to create
	//   3. UPDATE: path of the file to update
	//   4. MOVE: the new path of the moved file
	//   5. DELETE: path of the file to delete
	//   6. CHMOD: path of the file to modify permissions for
	FilePath []byte `protobuf:"bytes,2,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"`
	// previous_path is used in MOVE action to specify the path of the file to move.
	PreviousPath []byte `protobuf:"bytes,3,opt,name=previous_path,json=previousPath,proto3" json:"previous_path,omitempty"`
	// base64_content indicates the content of the file is base64 encoded. The encoding
	// must be the standard base64 encoding defined in RFC 4648. Only used for CREATE and
	// UPDATE actions.
	Base64Content bool `protobuf:"varint,4,opt,name=base64_content,json=base64Content,proto3" json:"base64_content,omitempty"`
	// execute_filemode determines whether the file is created with execute permissions.
	// The field is only used in CREATE and CHMOD actions.
	ExecuteFilemode bool `protobuf:"varint,5,opt,name=execute_filemode,json=executeFilemode,proto3" json:"execute_filemode,omitempty"`
	// Move actions that change the file path, but not its content, should set
	// infer_content to true instead of populating the content field. Ignored for
	// other action types.
	InferContent         bool     `protobuf:"varint,6,opt,name=infer_content,json=inferContent,proto3" json:"infer_content,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserCommitFilesActionHeader) Reset()         { *m = UserCommitFilesActionHeader{} }
func (m *UserCommitFilesActionHeader) String() string { return proto.CompactTextString(m) }
func (*UserCommitFilesActionHeader) ProtoMessage()    {}
func (*UserCommitFilesActionHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b4a5877375e491e, []int{21}
}

func (m *UserCommitFilesActionHeader) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserCommitFilesActionHeader.Unmarshal(m, b)
}
func (m *UserCommitFilesActionHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserCommitFilesActionHeader.Marshal(b, m, deterministic)
}
func (m *UserCommitFilesActionHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserCommitFilesActionHeader.Merge(m, src)
}
func (m *UserCommitFilesActionHeader) XXX_Size() int {
	return xxx_messageInfo_UserCommitFilesActionHeader.Size(m)
}
func (m *UserCommitFilesActionHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_UserCommitFilesActionHeader.DiscardUnknown(m)
}

var xxx_messageInfo_UserCommitFilesActionHeader proto.InternalMessageInfo

func (m *UserCommitFilesActionHeader) GetAction() UserCommitFilesActionHeader_ActionType {
	if m != nil {
		return m.Action
	}
	return UserCommitFilesActionHeader_CREATE
}

func (m *UserCommitFilesActionHeader) GetFilePath() []byte {
	if m != nil {
		return m.FilePath
	}
	return nil
}

func (m *UserCommitFilesActionHeader) GetPreviousPath() []byte {
	if m != nil {
		return m.PreviousPath
	}
	return nil
}

func (m *UserCommitFilesActionHeader) GetBase64Content() bool {
	if m != nil {
		return m.Base64Content
	}
	return false
}

func (m *UserCommitFilesActionHeader) GetExecuteFilemode() bool {
	if m != nil {
		return m.ExecuteFilemode
	}
	return false
}

func (m *UserCommitFilesActionHeader) GetInferContent() bool {
	if m != nil {
		return m.InferContent
	}
	return false
}

// UserCommitFilesAction is the request message used to stream in the actions to build a commit.
type UserCommitFilesAction struct {
	// Types that are valid to be assigned to UserCommitFilesActionPayload:
	//	*UserCommitFilesAction_Header
	//	*UserCommitFilesAction_Content
	UserCommitFilesActionPayload isUserCommitFilesAction_UserCommitFilesActionPayload `protobuf_oneof:"user_commit_files_action_payload"`
	XXX_NoUnkeyedLiteral         struct{}                                             `json:"-"`
	XXX_unrecognized             []byte                                               `json:"-"`
	XXX_sizecache                int32                                                `json:"-"`
}

func (m *UserCommitFilesAction) Reset()         { *m = UserCommitFilesAction{} }
func (m *UserCommitFilesAction) String() string { return proto.CompactTextString(m) }
func (*UserCommitFilesAction) ProtoMessage()    {}
func (*UserCommitFilesAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b4a5877375e491e, []int{22}
}

func (m *UserCommitFilesAction) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserCommitFilesAction.Unmarshal(m, b)
}
func (m *UserCommitFilesAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserCommitFilesAction.Marshal(b, m, deterministic)
}
func (m *UserCommitFilesAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserCommitFilesAction.Merge(m, src)
}
func (m *UserCommitFilesAction) XXX_Size() int {
	return xxx_messageInfo_UserCommitFilesAction.Size(m)
}
func (m *UserCommitFilesAction) XXX_DiscardUnknown() {
	xxx_messageInfo_UserCommitFilesAction.DiscardUnknown(m)
}

var xxx_messageInfo_UserCommitFilesAction proto.InternalMessageInfo

type isUserCommitFilesAction_UserCommitFilesActionPayload interface {
	isUserCommitFilesAction_UserCommitFilesActionPayload()
}

type UserCommitFilesAction_Header struct {
	Header *UserCommitFilesActionHeader `protobuf:"bytes,1,opt,name=header,proto3,oneof"`
}

type UserCommitFilesAction_Content struct {
	Content []byte `protobuf:"bytes,2,opt,name=content,proto3,oneof"`
}

func (*UserCommitFilesAction_Header) isUserCommitFilesAction_UserCommitFilesActionPayload() {}

func (*UserCommitFilesAction_Content) isUserCommitFilesAction_UserCommitFilesActionPayload() {}

func (m *UserCommitFilesAction) GetUserCommitFilesActionPayload() isUserCommitFilesAction_UserCommitFilesActionPayload {
	if m != nil {
		return m.UserCommitFilesActionPayload
	}
	return nil
}

func (m *UserCommitFilesAction) GetHeader() *UserCommitFilesActionHeader {
	if x, ok := m.GetUserCommitFilesActionPayload().(*UserCommitFilesAction_Header); ok {
		return x.Header
	}
	return nil
}

func (m *UserCommitFilesAction) GetContent() []byte {
	if x, ok := m.GetUserCommitFilesActionPayload().(*UserCommitFilesAction_Content); ok {
		return x.Content
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*UserCommitFilesAction) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*UserCommitFilesAction_Header)(nil),
		(*UserCommitFilesAction_Content)(nil),
	}
}

// UserCommitFilesRequestHeader is the header of the UserCommitFiles that defines the commit details,
// parent and other information related to the call.
type UserCommitFilesRequestHeader struct {
	// repository is the target repository where to apply the commit.
	Repository *Repository `protobuf:"bytes,1,opt,name=repository,proto3" json:"repository,omitempty"`
	// user is the user peforming the call.
	User *User `protobuf:"bytes,2,opt,name=user,proto3" json:"user,omitempty"`
	// branch_name is the name of the branch to point to the new commit. If start_sha and start_branch_name
	// are not defined, the commit of branch_name is used as the parent commit.
	BranchName []byte `protobuf:"bytes,3,opt,name=branch_name,json=branchName,proto3" json:"branch_name,omitempty"`
	// commit_message is the message to use in the commit.
	CommitMessage []byte `protobuf:"bytes,4,opt,name=commit_message,json=commitMessage,proto3" json:"commit_message,omitempty"`
	// commit_author_name is the commit author's name. If not provided, the user's name is
	// used instead.
	CommitAuthorName []byte `protobuf:"bytes,5,opt,name=commit_author_name,json=commitAuthorName,proto3" json:"commit_author_name,omitempty"`
	// commit_author_email is the commit author's email. If not provided, the user's email is
	// used instead.
	CommitAuthorEmail []byte `protobuf:"bytes,6,opt,name=commit_author_email,json=commitAuthorEmail,proto3" json:"commit_author_email,omitempty"`
	// start_branch_name specifies the branch whose commit to use as the parent commit. Takes priority
	// over branch_name. Optional.
	StartBranchName []byte `protobuf:"bytes,7,opt,name=start_branch_name,json=startBranchName,proto3" json:"start_branch_name,omitempty"`
	// start_repository specifies which contains the parent commit. If not specified, repository itself
	// is used to look up the parent commit. Optional.
	StartRepository *Repository `protobuf:"bytes,8,opt,name=start_repository,json=startRepository,proto3" json:"start_repository,omitempty"`
	// force determines whether to force update the target branch specified by branch_name to
	// point to the new commit.
	Force bool `protobuf:"varint,9,opt,name=force,proto3" json:"force,omitempty"`
	// start_sha specifies the SHA of the commit to use as the parent of new commit. Takes priority
	// over start_branch_name and branc_name. Optional.
	StartSha string `protobuf:"bytes,10,opt,name=start_sha,json=startSha,proto3" json:"start_sha,omitempty"`
	// timestamp is the optional timestamp to use for the commits as author and
	// committer date. If it's not set, the current time will be used.
	Timestamp            *timestamp.Timestamp `protobuf:"bytes,11,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *UserCommitFilesRequestHeader) Reset()         { *m = UserCommitFilesRequestHeader{} }
func (m *UserCommitFilesRequestHeader) String() string { return proto.CompactTextString(m) }
func (*UserCommitFilesRequestHeader) ProtoMessage()    {}
func (*UserCommitFilesRequestHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b4a5877375e491e, []int{23}
}

func (m *UserCommitFilesRequestHeader) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserCommitFilesRequestHeader.Unmarshal(m, b)
}
func (m *UserCommitFilesRequestHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserCommitFilesRequestHeader.Marshal(b, m, deterministic)
}
func (m *UserCommitFilesRequestHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserCommitFilesRequestHeader.Merge(m, src)
}
func (m *UserCommitFilesRequestHeader) XXX_Size() int {
	return xxx_messageInfo_UserCommitFilesRequestHeader.Size(m)
}
func (m *UserCommitFilesRequestHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_UserCommitFilesRequestHeader.DiscardUnknown(m)
}

var xxx_messageInfo_UserCommitFilesRequestHeader proto.InternalMessageInfo

func (m *UserCommitFilesRequestHeader) GetRepository() *Repository {
	if m != nil {
		return m.Repository
	}
	return nil
}

func (m *UserCommitFilesRequestHeader) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *UserCommitFilesRequestHeader) GetBranchName() []byte {
	if m != nil {
		return m.BranchName
	}
	return nil
}

func (m *UserCommitFilesRequestHeader) GetCommitMessage() []byte {
	if m != nil {
		return m.CommitMessage
	}
	return nil
}

func (m *UserCommitFilesRequestHeader) GetCommitAuthorName() []byte {
	if m != nil {
		return m.CommitAuthorName
	}
	return nil
}

func (m *UserCommitFilesRequestHeader) GetCommitAuthorEmail() []byte {
	if m != nil {
		return m.CommitAuthorEmail
	}
	return nil
}

func (m *UserCommitFilesRequestHeader) GetStartBranchName() []byte {
	if m != nil {
		return m.StartBranchName
	}
	return nil
}

func (m *UserCommitFilesRequestHeader) GetStartRepository() *Repository {
	if m != nil {
		return m.StartRepository
	}
	return nil
}

func (m *UserCommitFilesRequestHeader) GetForce() bool {
	if m != nil {
		return m.Force
	}
	return false
}

func (m *UserCommitFilesRequestHeader) GetStartSha() string {
	if m != nil {
		return m.StartSha
	}
	return ""
}

func (m *UserCommitFilesRequestHeader) GetTimestamp() *timestamp.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

// UserCommitFiles is the request of UserCommitFiles.
type UserCommitFilesRequest struct {
	// Types that are valid to be assigned to UserCommitFilesRequestPayload:
	//	*UserCommitFilesRequest_Header
	//	*UserCommitFilesRequest_Action
	UserCommitFilesRequestPayload isUserCommitFilesRequest_UserCommitFilesRequestPayload `protobuf_oneof:"user_commit_files_request_payload"`
	XXX_NoUnkeyedLiteral          struct{}                                               `json:"-"`
	XXX_unrecognized              []byte                                                 `json:"-"`
	XXX_sizecache                 int32                                                  `json:"-"`
}

func (m *UserCommitFilesRequest) Reset()         { *m = UserCommitFilesRequest{} }
func (m *UserCommitFilesRequest) String() string { return proto.CompactTextString(m) }
func (*UserCommitFilesRequest) ProtoMessage()    {}
func (*UserCommitFilesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b4a5877375e491e, []int{24}
}

func (m *UserCommitFilesRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserCommitFilesRequest.Unmarshal(m, b)
}
func (m *UserCommitFilesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserCommitFilesRequest.Marshal(b, m, deterministic)
}
func (m *UserCommitFilesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserCommitFilesRequest.Merge(m, src)
}
func (m *UserCommitFilesRequest) XXX_Size() int {
	return xxx_messageInfo_UserCommitFilesRequest.Size(m)
}
func (m *UserCommitFilesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UserCommitFilesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UserCommitFilesRequest proto.InternalMessageInfo

type isUserCommitFilesRequest_UserCommitFilesRequestPayload interface {
	isUserCommitFilesRequest_UserCommitFilesRequestPayload()
}

type UserCommitFilesRequest_Header struct {
	Header *UserCommitFilesRequestHeader `protobuf:"bytes,1,opt,name=header,proto3,oneof"`
}

type UserCommitFilesRequest_Action struct {
	Action *UserCommitFilesAction `protobuf:"bytes,2,opt,name=action,proto3,oneof"`
}

func (*UserCommitFilesRequest_Header) isUserCommitFilesRequest_UserCommitFilesRequestPayload() {}

func (*UserCommitFilesRequest_Action) isUserCommitFilesRequest_UserCommitFilesRequestPayload() {}

func (m *UserCommitFilesRequest) GetUserCommitFilesRequestPayload() isUserCommitFilesRequest_UserCommitFilesRequestPayload {
	if m != nil {
		return m.UserCommitFilesRequestPayload
	}
	return nil
}

func (m *UserCommitFilesRequest) GetHeader() *UserCommitFilesRequestHeader {
	if x, ok := m.GetUserCommitFilesRequestPayload().(*UserCommitFilesRequest_Header); ok {
		return x.Header
	}
	return nil
}

func (m *UserCommitFilesRequest) GetAction() *UserCommitFilesAction {
	if x, ok := m.GetUserCommitFilesRequestPayload().(*UserCommitFilesRequest_Action); ok {
		return x.Action
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*UserCommitFilesRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*UserCommitFilesRequest_Header)(nil),
		(*UserCommitFilesRequest_Action)(nil),
	}
}

// UserCommitFilesResponse is the response object of UserCommitFiles.
type UserCommitFilesResponse struct {
	// branch_update contains the details of the commit and the branch update.
	BranchUpdate *OperationBranchUpdate `protobuf:"bytes,1,opt,name=branch_update,json=branchUpdate,proto3" json:"branch_update,omitempty"`
	// index_error is set to the error message when an invalid action was attempted, such as
	// trying to create a file that already existed.
	IndexError string `protobuf:"bytes,2,opt,name=index_error,json=indexError,proto3" json:"index_error,omitempty"`
	// pre_receive_error is set when the pre-receive hook errored.
	PreReceiveError      string   `protobuf:"bytes,3,opt,name=pre_receive_error,json=preReceiveError,proto3" json:"pre_receive_error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserCommitFilesResponse) Reset()         { *m = UserCommitFilesResponse{} }
func (m *UserCommitFilesResponse) String() string { return proto.CompactTextString(m) }
func (*UserCommitFilesResponse) ProtoMessage()    {}
func (*UserCommitFilesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b4a5877375e491e, []int{25}
}

func (m *UserCommitFilesResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserCommitFilesResponse.Unmarshal(m, b)
}
func (m *UserCommitFilesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserCommitFilesResponse.Marshal(b, m, deterministic)
}
func (m *UserCommitFilesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserCommitFilesResponse.Merge(m, src)
}
func (m *UserCommitFilesResponse) XXX_Size() int {
	return xxx_messageInfo_UserCommitFilesResponse.Size(m)
}
func (m *UserCommitFilesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UserCommitFilesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UserCommitFilesResponse proto.InternalMessageInfo

func (m *UserCommitFilesResponse) GetBranchUpdate() *OperationBranchUpdate {
	if m != nil {
		return m.BranchUpdate
	}
	return nil
}

func (m *UserCommitFilesResponse) GetIndexError() string {
	if m != nil {
		return m.IndexError
	}
	return ""
}

func (m *UserCommitFilesResponse) GetPreReceiveError() string {
	if m != nil {
		return m.PreReceiveError
	}
	return ""
}

type UserRebaseConfirmableRequest struct {
	// Types that are valid to be assigned to UserRebaseConfirmableRequestPayload:
	//	*UserRebaseConfirmableRequest_Header_
	//	*UserRebaseConfirmableRequest_Apply
	UserRebaseConfirmableRequestPayload isUserRebaseConfirmableRequest_UserRebaseConfirmableRequestPayload `protobuf_oneof:"user_rebase_confirmable_request_payload"`
	XXX_NoUnkeyedLiteral                struct{}                                                           `json:"-"`
	XXX_unrecognized                    []byte                                                             `json:"-"`
	XXX_sizecache                       int32                                                              `json:"-"`
}

func (m *UserRebaseConfirmableRequest) Reset()         { *m = UserRebaseConfirmableRequest{} }
func (m *UserRebaseConfirmableRequest) String() string { return proto.CompactTextString(m) }
func (*UserRebaseConfirmableRequest) ProtoMessage()    {}
func (*UserRebaseConfirmableRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b4a5877375e491e, []int{26}
}

func (m *UserRebaseConfirmableRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserRebaseConfirmableRequest.Unmarshal(m, b)
}
func (m *UserRebaseConfirmableRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserRebaseConfirmableRequest.Marshal(b, m, deterministic)
}
func (m *UserRebaseConfirmableRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserRebaseConfirmableRequest.Merge(m, src)
}
func (m *UserRebaseConfirmableRequest) XXX_Size() int {
	return xxx_messageInfo_UserRebaseConfirmableRequest.Size(m)
}
func (m *UserRebaseConfirmableRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UserRebaseConfirmableRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UserRebaseConfirmableRequest proto.InternalMessageInfo

type isUserRebaseConfirmableRequest_UserRebaseConfirmableRequestPayload interface {
	isUserRebaseConfirmableRequest_UserRebaseConfirmableRequestPayload()
}

type UserRebaseConfirmableRequest_Header_ struct {
	Header *UserRebaseConfirmableRequest_Header `protobuf:"bytes,1,opt,name=header,proto3,oneof"`
}

type UserRebaseConfirmableRequest_Apply struct {
	Apply bool `protobuf:"varint,2,opt,name=apply,proto3,oneof"`
}

func (*UserRebaseConfirmableRequest_Header_) isUserRebaseConfirmableRequest_UserRebaseConfirmableRequestPayload() {
}

func (*UserRebaseConfirmableRequest_Apply) isUserRebaseConfirmableRequest_UserRebaseConfirmableRequestPayload() {
}

func (m *UserRebaseConfirmableRequest) GetUserRebaseConfirmableRequestPayload() isUserRebaseConfirmableRequest_UserRebaseConfirmableRequestPayload {
	if m != nil {
		return m.UserRebaseConfirmableRequestPayload
	}
	return nil
}

func (m *UserRebaseConfirmableRequest) GetHeader() *UserRebaseConfirmableRequest_Header {
	if x, ok := m.GetUserRebaseConfirmableRequestPayload().(*UserRebaseConfirmableRequest_Header_); ok {
		return x.Header
	}
	return nil
}

func (m *UserRebaseConfirmableRequest) GetApply() bool {
	if x, ok := m.GetUserRebaseConfirmableRequestPayload().(*UserRebaseConfirmableRequest_Apply); ok {
		return x.Apply
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*UserRebaseConfirmableRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*UserRebaseConfirmableRequest_Header_)(nil),
		(*UserRebaseConfirmableRequest_Apply)(nil),
	}
}

// Header contains information to compute the rebase and must be sent as
// first message.
type UserRebaseConfirmableRequest_Header struct {
	// repository is the repository in which the rebase will be computed and
	// applied.
	Repository *Repository `protobuf:"bytes,1,opt,name=repository,proto3" json:"repository,omitempty"`
	// user is the user to compute the rebase as. It will be used as
	// "committer" of rebased commits.
	User *User `protobuf:"bytes,2,opt,name=user,proto3" json:"user,omitempty"`
	// rebase_id is an ID which uniquely identifies the rebase. Internally, it
	// is used to identify the worktree in which the rebase shall be computed.
	// There cannot be two concurrent calls using the same rebase_id.
	RebaseId string `protobuf:"bytes,3,opt,name=rebase_id,json=rebaseId,proto3" json:"rebase_id,omitempty"`
	// branch is the branch onto which the rebase shall happen.
	Branch []byte `protobuf:"bytes,4,opt,name=branch,proto3" json:"branch,omitempty"`
	// branch_sha is the expected object ID which branch currently points to.
	// This is used as a safety guard to avoid races when branch has been
	// updated meanwhile.
	BranchSha string `protobuf:"bytes,5,opt,name=branch_sha,json=branchSha,proto3" json:"branch_sha,omitempty"`
	// remote_repository is the repository which contains the branch which
	// shall be rebased onto the local branch.
	RemoteRepository *Repository `protobuf:"bytes,6,opt,name=remote_repository,json=remoteRepository,proto3" json:"remote_repository,omitempty"`
	// remote_branch contains the branch name which shall re rebased onto the
	// local branch.
	RemoteBranch []byte `protobuf:"bytes,7,opt,name=remote_branch,json=remoteBranch,proto3" json:"remote_branch,omitempty"`
	// git_push_options contain options which shall be passed to the git hooks
	// when the local branch gets updated.
	GitPushOptions []string `protobuf:"bytes,8,rep,name=git_push_options,json=gitPushOptions,proto3" json:"git_push_options,omitempty"`
	// timestamp is the optional timestamp to use for the rebased commits as
	// committer date. If it's not set, the current time will be used.
	Timestamp            *timestamp.Timestamp `protobuf:"bytes,9,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *UserRebaseConfirmableRequest_Header) Reset()         { *m = UserRebaseConfirmableRequest_Header{} }
func (m *UserRebaseConfirmableRequest_Header) String() string { return proto.CompactTextString(m) }
func (*UserRebaseConfirmableRequest_Header) ProtoMessage()    {}
func (*UserRebaseConfirmableRequest_Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b4a5877375e491e, []int{26, 0}
}

func (m *UserRebaseConfirmableRequest_Header) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserRebaseConfirmableRequest_Header.Unmarshal(m, b)
}
func (m *UserRebaseConfirmableRequest_Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserRebaseConfirmableRequest_Header.Marshal(b, m, deterministic)
}
func (m *UserRebaseConfirmableRequest_Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserRebaseConfirmableRequest_Header.Merge(m, src)
}
func (m *UserRebaseConfirmableRequest_Header) XXX_Size() int {
	return xxx_messageInfo_UserRebaseConfirmableRequest_Header.Size(m)
}
func (m *UserRebaseConfirmableRequest_Header) XXX_DiscardUnknown() {
	xxx_messageInfo_UserRebaseConfirmableRequest_Header.DiscardUnknown(m)
}

var xxx_messageInfo_UserRebaseConfirmableRequest_Header proto.InternalMessageInfo

func (m *UserRebaseConfirmableRequest_Header) GetRepository() *Repository {
	if m != nil {
		return m.Repository
	}
	return nil
}

func (m *UserRebaseConfirmableRequest_Header) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *UserRebaseConfirmableRequest_Header) GetRebaseId() string {
	if m != nil {
		return m.RebaseId
	}
	return ""
}

func (m *UserRebaseConfirmableRequest_Header) GetBranch() []byte {
	if m != nil {
		return m.Branch
	}
	return nil
}

func (m *UserRebaseConfirmableRequest_Header) GetBranchSha() string {
	if m != nil {
		return m.BranchSha
	}
	return ""
}

func (m *UserRebaseConfirmableRequest_Header) GetRemoteRepository() *Repository {
	if m != nil {
		return m.RemoteRepository
	}
	return nil
}

func (m *UserRebaseConfirmableRequest_Header) GetRemoteBranch() []byte {
	if m != nil {
		return m.RemoteBranch
	}
	return nil
}

func (m *UserRebaseConfirmableRequest_Header) GetGitPushOptions() []string {
	if m != nil {
		return m.GitPushOptions
	}
	return nil
}

func (m *UserRebaseConfirmableRequest_Header) GetTimestamp() *timestamp.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

type UserRebaseConfirmableResponse struct {
	// Types that are valid to be assigned to UserRebaseConfirmableResponsePayload:
	//	*UserRebaseConfirmableResponse_RebaseSha
	//	*UserRebaseConfirmableResponse_RebaseApplied
	UserRebaseConfirmableResponsePayload isUserRebaseConfirmableResponse_UserRebaseConfirmableResponsePayload `protobuf_oneof:"user_rebase_confirmable_response_payload"`
	// pre_receive_error contains an error message if the rebase failed because
	// of an error raised by hooks.
	PreReceiveError string `protobuf:"bytes,3,opt,name=pre_receive_error,json=preReceiveError,proto3" json:"pre_receive_error,omitempty"`
	// git_error contains an error message if git operations have failed.
	GitError             string   `protobuf:"bytes,4,opt,name=git_error,json=gitError,proto3" json:"git_error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserRebaseConfirmableResponse) Reset()         { *m = UserRebaseConfirmableResponse{} }
func (m *UserRebaseConfirmableResponse) String() string { return proto.CompactTextString(m) }
func (*UserRebaseConfirmableResponse) ProtoMessage()    {}
func (*UserRebaseConfirmableResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b4a5877375e491e, []int{27}
}

func (m *UserRebaseConfirmableResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserRebaseConfirmableResponse.Unmarshal(m, b)
}
func (m *UserRebaseConfirmableResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserRebaseConfirmableResponse.Marshal(b, m, deterministic)
}
func (m *UserRebaseConfirmableResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserRebaseConfirmableResponse.Merge(m, src)
}
func (m *UserRebaseConfirmableResponse) XXX_Size() int {
	return xxx_messageInfo_UserRebaseConfirmableResponse.Size(m)
}
func (m *UserRebaseConfirmableResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UserRebaseConfirmableResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UserRebaseConfirmableResponse proto.InternalMessageInfo

type isUserRebaseConfirmableResponse_UserRebaseConfirmableResponsePayload interface {
	isUserRebaseConfirmableResponse_UserRebaseConfirmableResponsePayload()
}

type UserRebaseConfirmableResponse_RebaseSha struct {
	RebaseSha string `protobuf:"bytes,1,opt,name=rebase_sha,json=rebaseSha,proto3,oneof"`
}

type UserRebaseConfirmableResponse_RebaseApplied struct {
	RebaseApplied bool `protobuf:"varint,2,opt,name=rebase_applied,json=rebaseApplied,proto3,oneof"`
}

func (*UserRebaseConfirmableResponse_RebaseSha) isUserRebaseConfirmableResponse_UserRebaseConfirmableResponsePayload() {
}

func (*UserRebaseConfirmableResponse_RebaseApplied) isUserRebaseConfirmableResponse_UserRebaseConfirmableResponsePayload() {
}

func (m *UserRebaseConfirmableResponse) GetUserRebaseConfirmableResponsePayload() isUserRebaseConfirmableResponse_UserRebaseConfirmableResponsePayload {
	if m != nil {
		return m.UserRebaseConfirmableResponsePayload
	}
	return nil
}

func (m *UserRebaseConfirmableResponse) GetRebaseSha() string {
	if x, ok := m.GetUserRebaseConfirmableResponsePayload().(*UserRebaseConfirmableResponse_RebaseSha); ok {
		return x.RebaseSha
	}
	return ""
}

func (m *UserRebaseConfirmableResponse) GetRebaseApplied() bool {
	if x, ok := m.GetUserRebaseConfirmableResponsePayload().(*UserRebaseConfirmableResponse_RebaseApplied); ok {
		return x.RebaseApplied
	}
	return false
}

func (m *UserRebaseConfirmableResponse) GetPreReceiveError() string {
	if m != nil {
		return m.PreReceiveError
	}
	return ""
}

func (m *UserRebaseConfirmableResponse) GetGitError() string {
	if m != nil {
		return m.GitError
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*UserRebaseConfirmableResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*UserRebaseConfirmableResponse_RebaseSha)(nil),
		(*UserRebaseConfirmableResponse_RebaseApplied)(nil),
	}
}

type UserSquashRequest struct {
	// repository is the repository into which the squashed commit shall be
	// written.
	Repository *Repository `protobuf:"bytes,1,opt,name=repository,proto3" json:"repository,omitempty"`
	// user is used for authorization checks.
	User *User `protobuf:"bytes,2,opt,name=user,proto3" json:"user,omitempty"`
	// squash_id is used as a unique identifier for the squash. Internally, this
	// is used to identify the worktree in which the squash shall be computed. No
	// two UserSquash RPCs may run with the same ID.
	SquashId string `protobuf:"bytes,3,opt,name=squash_id,json=squashId,proto3" json:"squash_id,omitempty"`
	// start_sha is the object ID of the start commit of the range which shall be
	// squashed.
	StartSha string `protobuf:"bytes,5,opt,name=start_sha,json=startSha,proto3" json:"start_sha,omitempty"`
	// end_sha is the object ID of the end commit of the range which shall be
	// squashed.
	EndSha string `protobuf:"bytes,6,opt,name=end_sha,json=endSha,proto3" json:"end_sha,omitempty"`
	// author will be used as the author of the squashed commit.
	Author *User `protobuf:"bytes,7,opt,name=author,proto3" json:"author,omitempty"`
	// commit_message is the message to be used for the squashed commit.
	CommitMessage []byte `protobuf:"bytes,8,opt,name=commit_message,json=commitMessage,proto3" json:"commit_message,omitempty"`
	// timestamp is the optional timestamp to use for the squashed commit as
	// committer date. If it's not set, the current time will be used.
	Timestamp            *timestamp.Timestamp `protobuf:"bytes,9,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *UserSquashRequest) Reset()         { *m = UserSquashRequest{} }
func (m *UserSquashRequest) String() string { return proto.CompactTextString(m) }
func (*UserSquashRequest) ProtoMessage()    {}
func (*UserSquashRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b4a5877375e491e, []int{28}
}

func (m *UserSquashRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserSquashRequest.Unmarshal(m, b)
}
func (m *UserSquashRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserSquashRequest.Marshal(b, m, deterministic)
}
func (m *UserSquashRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserSquashRequest.Merge(m, src)
}
func (m *UserSquashRequest) XXX_Size() int {
	return xxx_messageInfo_UserSquashRequest.Size(m)
}
func (m *UserSquashRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UserSquashRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UserSquashRequest proto.InternalMessageInfo

func (m *UserSquashRequest) GetRepository() *Repository {
	if m != nil {
		return m.Repository
	}
	return nil
}

func (m *UserSquashRequest) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *UserSquashRequest) GetSquashId() string {
	if m != nil {
		return m.SquashId
	}
	return ""
}

func (m *UserSquashRequest) GetStartSha() string {
	if m != nil {
		return m.StartSha
	}
	return ""
}

func (m *UserSquashRequest) GetEndSha() string {
	if m != nil {
		return m.EndSha
	}
	return ""
}

func (m *UserSquashRequest) GetAuthor() *User {
	if m != nil {
		return m.Author
	}
	return nil
}

func (m *UserSquashRequest) GetCommitMessage() []byte {
	if m != nil {
		return m.CommitMessage
	}
	return nil
}

func (m *UserSquashRequest) GetTimestamp() *timestamp.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

type UserSquashResponse struct {
	// squash_sha is the object ID of the squashed commit.
	SquashSha            string   `protobuf:"bytes,1,opt,name=squash_sha,json=squashSha,proto3" json:"squash_sha,omitempty"`
	GitError             string   `protobuf:"bytes,3,opt,name=git_error,json=gitError,proto3" json:"git_error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserSquashResponse) Reset()         { *m = UserSquashResponse{} }
func (m *UserSquashResponse) String() string { return proto.CompactTextString(m) }
func (*UserSquashResponse) ProtoMessage()    {}
func (*UserSquashResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b4a5877375e491e, []int{29}
}

func (m *UserSquashResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserSquashResponse.Unmarshal(m, b)
}
func (m *UserSquashResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserSquashResponse.Marshal(b, m, deterministic)
}
func (m *UserSquashResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserSquashResponse.Merge(m, src)
}
func (m *UserSquashResponse) XXX_Size() int {
	return xxx_messageInfo_UserSquashResponse.Size(m)
}
func (m *UserSquashResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UserSquashResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UserSquashResponse proto.InternalMessageInfo

func (m *UserSquashResponse) GetSquashSha() string {
	if m != nil {
		return m.SquashSha
	}
	return ""
}

func (m *UserSquashResponse) GetGitError() string {
	if m != nil {
		return m.GitError
	}
	return ""
}

type UserApplyPatchRequest struct {
	// Types that are valid to be assigned to UserApplyPatchRequestPayload:
	//	*UserApplyPatchRequest_Header_
	//	*UserApplyPatchRequest_Patches
	UserApplyPatchRequestPayload isUserApplyPatchRequest_UserApplyPatchRequestPayload `protobuf_oneof:"user_apply_patch_request_payload"`
	XXX_NoUnkeyedLiteral         struct{}                                             `json:"-"`
	XXX_unrecognized             []byte                                               `json:"-"`
	XXX_sizecache                int32                                                `json:"-"`
}

func (m *UserApplyPatchRequest) Reset()         { *m = UserApplyPatchRequest{} }
func (m *UserApplyPatchRequest) String() string { return proto.CompactTextString(m) }
func (*UserApplyPatchRequest) ProtoMessage()    {}
func (*UserApplyPatchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b4a5877375e491e, []int{30}
}

func (m *UserApplyPatchRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserApplyPatchRequest.Unmarshal(m, b)
}
func (m *UserApplyPatchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserApplyPatchRequest.Marshal(b, m, deterministic)
}
func (m *UserApplyPatchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserApplyPatchRequest.Merge(m, src)
}
func (m *UserApplyPatchRequest) XXX_Size() int {
	return xxx_messageInfo_UserApplyPatchRequest.Size(m)
}
func (m *UserApplyPatchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UserApplyPatchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UserApplyPatchRequest proto.InternalMessageInfo

type isUserApplyPatchRequest_UserApplyPatchRequestPayload interface {
	isUserApplyPatchRequest_UserApplyPatchRequestPayload()
}

type UserApplyPatchRequest_Header_ struct {
	Header *UserApplyPatchRequest_Header `protobuf:"bytes,1,opt,name=header,proto3,oneof"`
}

type UserApplyPatchRequest_Patches struct {
	Patches []byte `protobuf:"bytes,2,opt,name=patches,proto3,oneof"`
}

func (*UserApplyPatchRequest_Header_) isUserApplyPatchRequest_UserApplyPatchRequestPayload() {}

func (*UserApplyPatchRequest_Patches) isUserApplyPatchRequest_UserApplyPatchRequestPayload() {}

func (m *UserApplyPatchRequest) GetUserApplyPatchRequestPayload() isUserApplyPatchRequest_UserApplyPatchRequestPayload {
	if m != nil {
		return m.UserApplyPatchRequestPayload
	}
	return nil
}

func (m *UserApplyPatchRequest) GetHeader() *UserApplyPatchRequest_Header {
	if x, ok := m.GetUserApplyPatchRequestPayload().(*UserApplyPatchRequest_Header_); ok {
		return x.Header
	}
	return nil
}

func (m *UserApplyPatchRequest) GetPatches() []byte {
	if x, ok := m.GetUserApplyPatchRequestPayload().(*UserApplyPatchRequest_Patches); ok {
		return x.Patches
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*UserApplyPatchRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*UserApplyPatchRequest_Header_)(nil),
		(*UserApplyPatchRequest_Patches)(nil),
	}
}

// Header contains information about how to apply the patches.
type UserApplyPatchRequest_Header struct {
	// repository is the repository to which the patches shall be applied to.
	Repository *Repository `protobuf:"bytes,1,opt,name=repository,proto3" json:"repository,omitempty"`
	// user is used for authentication.
	User *User `protobuf:"bytes,2,opt,name=user,proto3" json:"user,omitempty"`
	// target_branch is the branch onto which the patches shall be applied.
	TargetBranch []byte `protobuf:"bytes,3,opt,name=target_branch,json=targetBranch,proto3" json:"target_branch,omitempty"`
	// timestamp is the optional timestamp to use for the squashed commit as
	// committer date. If it's not set, the current time will be used.
	Timestamp            *timestamp.Timestamp `protobuf:"bytes,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *UserApplyPatchRequest_Header) Reset()         { *m = UserApplyPatchRequest_Header{} }
func (m *UserApplyPatchRequest_Header) String() string { return proto.CompactTextString(m) }
func (*UserApplyPatchRequest_Header) ProtoMessage()    {}
func (*UserApplyPatchRequest_Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b4a5877375e491e, []int{30, 0}
}

func (m *UserApplyPatchRequest_Header) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserApplyPatchRequest_Header.Unmarshal(m, b)
}
func (m *UserApplyPatchRequest_Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserApplyPatchRequest_Header.Marshal(b, m, deterministic)
}
func (m *UserApplyPatchRequest_Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserApplyPatchRequest_Header.Merge(m, src)
}
func (m *UserApplyPatchRequest_Header) XXX_Size() int {
	return xxx_messageInfo_UserApplyPatchRequest_Header.Size(m)
}
func (m *UserApplyPatchRequest_Header) XXX_DiscardUnknown() {
	xxx_messageInfo_UserApplyPatchRequest_Header.DiscardUnknown(m)
}

var xxx_messageInfo_UserApplyPatchRequest_Header proto.InternalMessageInfo

func (m *UserApplyPatchRequest_Header) GetRepository() *Repository {
	if m != nil {
		return m.Repository
	}
	return nil
}

func (m *UserApplyPatchRequest_Header) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *UserApplyPatchRequest_Header) GetTargetBranch() []byte {
	if m != nil {
		return m.TargetBranch
	}
	return nil
}

func (m *UserApplyPatchRequest_Header) GetTimestamp() *timestamp.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

type UserApplyPatchResponse struct {
	// branch_update contains information about the updated branch.
	BranchUpdate         *OperationBranchUpdate `protobuf:"bytes,1,opt,name=branch_update,json=branchUpdate,proto3" json:"branch_update,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *UserApplyPatchResponse) Reset()         { *m = UserApplyPatchResponse{} }
func (m *UserApplyPatchResponse) String() string { return proto.CompactTextString(m) }
func (*UserApplyPatchResponse) ProtoMessage()    {}
func (*UserApplyPatchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b4a5877375e491e, []int{31}
}

func (m *UserApplyPatchResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserApplyPatchResponse.Unmarshal(m, b)
}
func (m *UserApplyPatchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserApplyPatchResponse.Marshal(b, m, deterministic)
}
func (m *UserApplyPatchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserApplyPatchResponse.Merge(m, src)
}
func (m *UserApplyPatchResponse) XXX_Size() int {
	return xxx_messageInfo_UserApplyPatchResponse.Size(m)
}
func (m *UserApplyPatchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UserApplyPatchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UserApplyPatchResponse proto.InternalMessageInfo

func (m *UserApplyPatchResponse) GetBranchUpdate() *OperationBranchUpdate {
	if m != nil {
		return m.BranchUpdate
	}
	return nil
}

type UserUpdateSubmoduleRequest struct {
	// repository is the repository in which the submodule shall be updated.
	Repository *Repository `protobuf:"bytes,1,opt,name=repository,proto3" json:"repository,omitempty"`
	// user is used both for authorization and as author/committer of the
	// resulting commit.
	User *User `protobuf:"bytes,2,opt,name=user,proto3" json:"user,omitempty"`
	// commit_sha is the object ID the submodule shall be updated to.
	CommitSha string `protobuf:"bytes,3,opt,name=commit_sha,json=commitSha,proto3" json:"commit_sha,omitempty"`
	// branch is the branch which shall be updated. This is the unqualified name
	// of the branch, it must not have a "refs/heads/" prefix.
	Branch []byte `protobuf:"bytes,4,opt,name=branch,proto3" json:"branch,omitempty"`
	// submodule is the path to the submodule which shall be updated.
	Submodule []byte `protobuf:"bytes,5,opt,name=submodule,proto3" json:"submodule,omitempty"`
	// commit_message is the message updating the submodule.
	CommitMessage []byte `protobuf:"bytes,6,opt,name=commit_message,json=commitMessage,proto3" json:"commit_message,omitempty"`
	// timestamp is the optional timestamp to use for the commit updating the
	// submodule as committer date. If it's not set, the current time will be
	// used.
	Timestamp            *timestamp.Timestamp `protobuf:"bytes,7,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *UserUpdateSubmoduleRequest) Reset()         { *m = UserUpdateSubmoduleRequest{} }
func (m *UserUpdateSubmoduleRequest) String() string { return proto.CompactTextString(m) }
func (*UserUpdateSubmoduleRequest) ProtoMessage()    {}
func (*UserUpdateSubmoduleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b4a5877375e491e, []int{32}
}

func (m *UserUpdateSubmoduleRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserUpdateSubmoduleRequest.Unmarshal(m, b)
}
func (m *UserUpdateSubmoduleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserUpdateSubmoduleRequest.Marshal(b, m, deterministic)
}
func (m *UserUpdateSubmoduleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserUpdateSubmoduleRequest.Merge(m, src)
}
func (m *UserUpdateSubmoduleRequest) XXX_Size() int {
	return xxx_messageInfo_UserUpdateSubmoduleRequest.Size(m)
}
func (m *UserUpdateSubmoduleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UserUpdateSubmoduleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UserUpdateSubmoduleRequest proto.InternalMessageInfo

func (m *UserUpdateSubmoduleRequest) GetRepository() *Repository {
	if m != nil {
		return m.Repository
	}
	return nil
}

func (m *UserUpdateSubmoduleRequest) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *UserUpdateSubmoduleRequest) GetCommitSha() string {
	if m != nil {
		return m.CommitSha
	}
	return ""
}

func (m *UserUpdateSubmoduleRequest) GetBranch() []byte {
	if m != nil {
		return m.Branch
	}
	return nil
}

func (m *UserUpdateSubmoduleRequest) GetSubmodule() []byte {
	if m != nil {
		return m.Submodule
	}
	return nil
}

func (m *UserUpdateSubmoduleRequest) GetCommitMessage() []byte {
	if m != nil {
		return m.CommitMessage
	}
	return nil
}

func (m *UserUpdateSubmoduleRequest) GetTimestamp() *timestamp.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

type UserUpdateSubmoduleResponse struct {
	// branch_update contains information about the updated branch.
	BranchUpdate *OperationBranchUpdate `protobuf:"bytes,1,opt,name=branch_update,json=branchUpdate,proto3" json:"branch_update,omitempty"`
	// pre_receive_error contains an error message if the pre-receive hook
	// rejects the update.
	PreReceiveError string `protobuf:"bytes,2,opt,name=pre_receive_error,json=preReceiveError,proto3" json:"pre_receive_error,omitempty"`
	// commit_error contains an error message if committing the update fails.
	CommitError          string   `protobuf:"bytes,4,opt,name=commit_error,json=commitError,proto3" json:"commit_error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserUpdateSubmoduleResponse) Reset()         { *m = UserUpdateSubmoduleResponse{} }
func (m *UserUpdateSubmoduleResponse) String() string { return proto.CompactTextString(m) }
func (*UserUpdateSubmoduleResponse) ProtoMessage()    {}
func (*UserUpdateSubmoduleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b4a5877375e491e, []int{33}
}

func (m *UserUpdateSubmoduleResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserUpdateSubmoduleResponse.Unmarshal(m, b)
}
func (m *UserUpdateSubmoduleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserUpdateSubmoduleResponse.Marshal(b, m, deterministic)
}
func (m *UserUpdateSubmoduleResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserUpdateSubmoduleResponse.Merge(m, src)
}
func (m *UserUpdateSubmoduleResponse) XXX_Size() int {
	return xxx_messageInfo_UserUpdateSubmoduleResponse.Size(m)
}
func (m *UserUpdateSubmoduleResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UserUpdateSubmoduleResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UserUpdateSubmoduleResponse proto.InternalMessageInfo

func (m *UserUpdateSubmoduleResponse) GetBranchUpdate() *OperationBranchUpdate {
	if m != nil {
		return m.BranchUpdate
	}
	return nil
}

func (m *UserUpdateSubmoduleResponse) GetPreReceiveError() string {
	if m != nil {
		return m.PreReceiveError
	}
	return ""
}

func (m *UserUpdateSubmoduleResponse) GetCommitError() string {
	if m != nil {
		return m.CommitError
	}
	return ""
}

func init() {
	proto.RegisterEnum("gitaly.UserCherryPickResponse_CreateTreeError", UserCherryPickResponse_CreateTreeError_name, UserCherryPickResponse_CreateTreeError_value)
	proto.RegisterEnum("gitaly.UserRevertResponse_CreateTreeError", UserRevertResponse_CreateTreeError_name, UserRevertResponse_CreateTreeError_value)
	proto.RegisterEnum("gitaly.UserCommitFilesActionHeader_ActionType", UserCommitFilesActionHeader_ActionType_name, UserCommitFilesActionHeader_ActionType_value)
	proto.RegisterType((*UserCreateBranchRequest)(nil), "gitaly.UserCreateBranchRequest")
	proto.RegisterType((*UserCreateBranchResponse)(nil), "gitaly.UserCreateBranchResponse")
	proto.RegisterType((*UserUpdateBranchRequest)(nil), "gitaly.UserUpdateBranchRequest")
	proto.RegisterType((*UserUpdateBranchResponse)(nil), "gitaly.UserUpdateBranchResponse")
	proto.RegisterType((*UserDeleteBranchRequest)(nil), "gitaly.UserDeleteBranchRequest")
	proto.RegisterType((*UserDeleteBranchResponse)(nil), "gitaly.UserDeleteBranchResponse")
	proto.RegisterType((*UserDeleteTagRequest)(nil), "gitaly.UserDeleteTagRequest")
	proto.RegisterType((*UserDeleteTagResponse)(nil), "gitaly.UserDeleteTagResponse")
	proto.RegisterType((*UserCreateTagRequest)(nil), "gitaly.UserCreateTagRequest")
	proto.RegisterType((*UserCreateTagResponse)(nil), "gitaly.UserCreateTagResponse")
	proto.RegisterType((*UserMergeBranchRequest)(nil), "gitaly.UserMergeBranchRequest")
	proto.RegisterType((*UserMergeBranchResponse)(nil), "gitaly.UserMergeBranchResponse")
	proto.RegisterType((*UserMergeToRefRequest)(nil), "gitaly.UserMergeToRefRequest")
	proto.RegisterType((*UserMergeToRefResponse)(nil), "gitaly.UserMergeToRefResponse")
	proto.RegisterType((*OperationBranchUpdate)(nil), "gitaly.OperationBranchUpdate")
	proto.RegisterType((*UserFFBranchRequest)(nil), "gitaly.UserFFBranchRequest")
	proto.RegisterType((*UserFFBranchResponse)(nil), "gitaly.UserFFBranchResponse")
	proto.RegisterType((*UserCherryPickRequest)(nil), "gitaly.UserCherryPickRequest")
	proto.RegisterType((*UserCherryPickResponse)(nil), "gitaly.UserCherryPickResponse")
	proto.RegisterType((*UserRevertRequest)(nil), "gitaly.UserRevertRequest")
	proto.RegisterType((*UserRevertResponse)(nil), "gitaly.UserRevertResponse")
	proto.RegisterType((*UserCommitFilesActionHeader)(nil), "gitaly.UserCommitFilesActionHeader")
	proto.RegisterType((*UserCommitFilesAction)(nil), "gitaly.UserCommitFilesAction")
	proto.RegisterType((*UserCommitFilesRequestHeader)(nil), "gitaly.UserCommitFilesRequestHeader")
	proto.RegisterType((*UserCommitFilesRequest)(nil), "gitaly.UserCommitFilesRequest")
	proto.RegisterType((*UserCommitFilesResponse)(nil), "gitaly.UserCommitFilesResponse")
	proto.RegisterType((*UserRebaseConfirmableRequest)(nil), "gitaly.UserRebaseConfirmableRequest")
	proto.RegisterType((*UserRebaseConfirmableRequest_Header)(nil), "gitaly.UserRebaseConfirmableRequest.Header")
	proto.RegisterType((*UserRebaseConfirmableResponse)(nil), "gitaly.UserRebaseConfirmableResponse")
	proto.RegisterType((*UserSquashRequest)(nil), "gitaly.UserSquashRequest")
	proto.RegisterType((*UserSquashResponse)(nil), "gitaly.UserSquashResponse")
	proto.RegisterType((*UserApplyPatchRequest)(nil), "gitaly.UserApplyPatchRequest")
	proto.RegisterType((*UserApplyPatchRequest_Header)(nil), "gitaly.UserApplyPatchRequest.Header")
	proto.RegisterType((*UserApplyPatchResponse)(nil), "gitaly.UserApplyPatchResponse")
	proto.RegisterType((*UserUpdateSubmoduleRequest)(nil), "gitaly.UserUpdateSubmoduleRequest")
	proto.RegisterType((*UserUpdateSubmoduleResponse)(nil), "gitaly.UserUpdateSubmoduleResponse")
}

func init() { proto.RegisterFile("operations.proto", fileDescriptor_1b4a5877375e491e) }

var fileDescriptor_1b4a5877375e491e = []byte{
	// 2239 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5a, 0xdf, 0x6f, 0x1b, 0x59,
	0xf5, 0xcf, 0xd8, 0x8e, 0x63, 0x9f, 0x38, 0x8e, 0x33, 0xed, 0xb6, 0x5e, 0xb7, 0xf9, 0x26, 0x3b,
	0x69, 0xbf, 0x4d, 0xcb, 0xe2, 0xac, 0xca, 0x0a, 0xf6, 0x65, 0x41, 0x8d, 0xe3, 0x90, 0x96, 0x4d,
	0x13, 0xa6, 0x2e, 0x68, 0xd1, 0xc2, 0x68, 0x62, 0x5f, 0xdb, 0x23, 0x6c, 0xcf, 0xec, 0x9d, 0x71,
	0xb6, 0xe1, 0x81, 0x07, 0x1e, 0x78, 0x40, 0xe2, 0x69, 0xa5, 0x5d, 0xfe, 0x02, 0x1e, 0x10, 0xf0,
	0x08, 0x7f, 0x00, 0xd2, 0x4a, 0x3c, 0xf1, 0x17, 0xc0, 0x1f, 0x80, 0x84, 0x84, 0x90, 0x90, 0x10,
	0x4f, 0xe8, 0xde, 0x73, 0xc6, 0x9e, 0x3b, 0x33, 0x4e, 0x93, 0x6e, 0x9a, 0xad, 0x10, 0x6f, 0xbe,
	0xe7, 0x9e, 0x39, 0xf7, 0x9e, 0xcf, 0xf9, 0x71, 0xcf, 0x3d, 0xd7, 0x50, 0x71, 0x3d, 0xc6, 0xed,
	0xc0, 0x71, 0x47, 0x7e, 0xdd, 0xe3, 0x6e, 0xe0, 0xea, 0xf9, 0x9e, 0x13, 0xd8, 0x83, 0x93, 0x1a,
	0x0c, 0x9c, 0x51, 0x80, 0xb4, 0x5a, 0xc9, 0xef, 0xdb, 0x9c, 0x75, 0x68, 0xb4, 0xd6, 0x73, 0xdd,
	0xde, 0x80, 0x6d, 0xc9, 0xd1, 0xd1, 0xb8, 0xbb, 0x15, 0x38, 0x43, 0xe6, 0x07, 0xf6, 0xd0, 0x43,
	0x06, 0xe3, 0xf7, 0x1a, 0x5c, 0x7f, 0xea, 0x33, 0xde, 0xe0, 0xcc, 0x0e, 0xd8, 0x36, 0xb7, 0x47,
	0xed, 0xbe, 0xc9, 0x3e, 0x1c, 0x33, 0x3f, 0xd0, 0xdf, 0x01, 0xe0, 0xcc, 0x73, 0x7d, 0x27, 0x70,
	0xf9, 0x49, 0x55, 0x5b, 0xd7, 0x36, 0x17, 0xef, 0xeb, 0x75, 0x5c, 0xb3, 0x6e, 0x4e, 0x66, 0xb6,
	0x73, 0xbf, 0xf8, 0xec, 0x4d, 0xcd, 0x8c, 0xf0, 0xea, 0x6b, 0xb0, 0x78, 0x24, 0x45, 0x59, 0x23,
	0x7b, 0xc8, 0xaa, 0x99, 0x75, 0x6d, 0xb3, 0x64, 0x02, 0x92, 0x1e, 0xdb, 0x43, 0xa6, 0xaf, 0x43,
	0x6e, 0xec, 0x33, 0x5e, 0xcd, 0x4a, 0xa1, 0xa5, 0x50, 0xa8, 0xd8, 0x89, 0x29, 0x67, 0x84, 0x08,
	0x3f, 0xb0, 0x79, 0x60, 0x79, 0xae, 0x33, 0x0a, 0xaa, 0x39, 0x14, 0x21, 0x49, 0x87, 0x82, 0x62,
	0x8c, 0xa0, 0x9a, 0xdc, 0xb8, 0xef, 0xb9, 0x23, 0x9f, 0xe9, 0xff, 0x0f, 0x79, 0x5c, 0x8c, 0x76,
	0x5d, 0x0e, 0x17, 0x20, 0x3e, 0x9a, 0xd5, 0xef, 0xc1, 0x8a, 0xc7, 0x99, 0xc5, 0x59, 0x9b, 0x39,
	0xc7, 0xcc, 0x62, 0x9c, 0xbb, 0x5c, 0xee, 0xb6, 0x68, 0x2e, 0x7b, 0x9c, 0x99, 0x48, 0x6f, 0x0a,
	0xb2, 0xf1, 0x19, 0x21, 0xf5, 0xd4, 0xeb, 0xbc, 0x5a, 0x48, 0x5d, 0x83, 0xfc, 0x88, 0x7d, 0xc4,
	0xd9, 0x31, 0x81, 0x44, 0x23, 0x41, 0x77, 0x07, 0x1d, 0x41, 0x9f, 0x47, 0x3a, 0x8e, 0x8c, 0x5d,
	0x04, 0x4e, 0xd5, 0x83, 0x80, 0x4b, 0x05, 0x44, 0x4b, 0x07, 0xe4, 0x13, 0x02, 0x64, 0x87, 0x0d,
	0xd8, 0xab, 0x04, 0x48, 0xa8, 0xa0, 0xba, 0xaf, 0x17, 0x50, 0xf0, 0xe7, 0x1a, 0x5c, 0x9d, 0x0a,
	0x6a, 0xd9, 0xbd, 0xcf, 0xaf, 0xdd, 0xeb, 0x50, 0x08, 0xec, 0x5e, 0x54, 0xb5, 0x85, 0xc0, 0xee,
	0x9d, 0x51, 0xaf, 0x06, 0xbc, 0x16, 0xdb, 0xce, 0x0b, 0x28, 0xf5, 0xb3, 0x0c, 0x2a, 0x85, 0x71,
	0xf3, 0x85, 0x2b, 0xa5, 0xdf, 0x81, 0xe5, 0xc0, 0xe6, 0x3d, 0x16, 0x58, 0x9c, 0x1d, 0x3b, 0xbe,
	0xe3, 0x8e, 0xc8, 0x8d, 0xcb, 0x48, 0x36, 0x89, 0xaa, 0x57, 0x61, 0x61, 0xc8, 0x7c, 0xdf, 0xee,
	0x31, 0xf2, 0xe7, 0x70, 0xa8, 0xbf, 0x03, 0xc5, 0x49, 0x5a, 0xab, 0x2e, 0xc8, 0x95, 0x6a, 0x75,
	0x4c, 0x7c, 0xf5, 0x30, 0xf1, 0xd5, 0x5b, 0x21, 0x87, 0x39, 0x65, 0x36, 0x7e, 0x84, 0x88, 0x46,
	0xb0, 0x20, 0x44, 0x57, 0x21, 0x1b, 0xd8, 0x3d, 0x42, 0x61, 0x31, 0xdc, 0xb6, 0xe0, 0x10, 0x74,
	0x11, 0x5a, 0xec, 0x99, 0xe3, 0x07, 0xbe, 0xd4, 0xb7, 0x60, 0xd2, 0x28, 0xdd, 0x10, 0xd9, 0x74,
	0x43, 0x7c, 0x9c, 0x81, 0x6b, 0x62, 0xf1, 0x7d, 0xc6, 0x7b, 0x17, 0x16, 0x3d, 0x21, 0xde, 0x99,
	0x99, 0x78, 0xdf, 0x80, 0x62, 0xdb, 0x1d, 0x0e, 0x9d, 0xc0, 0x72, 0x3a, 0xb4, 0xb5, 0x02, 0x12,
	0x1e, 0x76, 0x84, 0x5e, 0x94, 0x37, 0x29, 0x95, 0x50, 0x9e, 0x7c, 0x09, 0xd8, 0xeb, 0x57, 0x61,
	0xde, 0xf6, 0xbc, 0xc1, 0x49, 0x35, 0x2f, 0x21, 0xc4, 0x81, 0xf1, 0x6b, 0x4a, 0x2a, 0x0a, 0x2a,
	0x64, 0x14, 0x65, 0xeb, 0x5a, 0x6c, 0xeb, 0xdb, 0xb0, 0x44, 0x79, 0x63, 0x2c, 0x13, 0x1b, 0xb9,
	0xdc, 0x6a, 0x08, 0xc1, 0x41, 0x78, 0x78, 0xa2, 0x50, 0xcc, 0x7e, 0x66, 0xe9, 0x28, 0x32, 0x4a,
	0x37, 0x5f, 0x2e, 0xd5, 0x7c, 0x8f, 0x72, 0x85, 0x4c, 0x25, 0x6b, 0xfc, 0x3d, 0x83, 0x1e, 0x24,
	0xb7, 0xdb, 0x72, 0x4d, 0xd6, 0xbd, 0x0c, 0x1b, 0xae, 0x02, 0xf8, 0xee, 0x98, 0xb7, 0x99, 0xe5,
	0xf7, 0x6d, 0x32, 0x62, 0x11, 0x29, 0x4f, 0xfa, 0xf6, 0x4c, 0x2b, 0xae, 0x02, 0x4c, 0x42, 0xad,
	0x4b, 0x86, 0x2c, 0x86, 0x51, 0xd6, 0x8d, 0x1a, 0x39, 0xaf, 0x1a, 0x79, 0x13, 0x2a, 0x5d, 0x87,
	0xfb, 0x81, 0xe5, 0xd9, 0x9c, 0x8d, 0xf0, 0xf3, 0x05, 0x0c, 0x52, 0x49, 0x3f, 0x94, 0x64, 0x21,
	0xe3, 0x0e, 0x2c, 0xdb, 0x83, 0x81, 0xfb, 0x91, 0xd5, 0x76, 0x47, 0xdd, 0x81, 0xd3, 0x0e, 0xfc,
	0x6a, 0x41, 0x9a, 0xb7, 0x2c, 0xc9, 0x8d, 0x90, 0xaa, 0xfa, 0x4d, 0xf1, 0x3c, 0x31, 0x6b, 0x47,
	0xc2, 0x86, 0x10, 0x3f, 0x8b, 0x7f, 0x9c, 0xe7, 0xa8, 0xff, 0x31, 0xbc, 0x96, 0xea, 0x2e, 0xa7,
	0xaf, 0xf0, 0x06, 0x94, 0x84, 0x15, 0xad, 0xb6, 0xcc, 0x26, 0x1d, 0x4a, 0x0d, 0x8b, 0x82, 0x86,
	0x09, 0xa6, 0xa3, 0xdf, 0x86, 0x32, 0x39, 0x69, 0xc8, 0x94, 0x95, 0x4c, 0xe4, 0xba, 0xc4, 0x66,
	0xfc, 0x52, 0x83, 0x2b, 0x42, 0xc7, 0xdd, 0xdd, 0x57, 0x3b, 0x2f, 0x18, 0x3f, 0xa5, 0x13, 0x72,
	0xba, 0x51, 0x32, 0x45, 0x22, 0x1a, 0xb5, 0x0b, 0x8a, 0xc6, 0x19, 0x16, 0xfb, 0x34, 0x4b, 0x99,
	0xbc, 0xcf, 0x38, 0x3f, 0x39, 0x74, 0xda, 0x3f, 0xbc, 0x0c, 0xcc, 0xee, 0x42, 0x1e, 0x21, 0xa2,
	0x64, 0xb3, 0x12, 0xf2, 0x7c, 0xd3, 0x09, 0x1a, 0x72, 0xc2, 0x24, 0x86, 0x78, 0x59, 0x93, 0x4b,
	0x94, 0x35, 0xb3, 0x53, 0xec, 0x3d, 0x58, 0xc1, 0x4a, 0x38, 0x2a, 0x00, 0x23, 0x74, 0x59, 0x4e,
	0x6c, 0x4f, 0xa5, 0xbc, 0x0b, 0x15, 0xe4, 0x8d, 0xe8, 0xbc, 0x30, 0x4b, 0x67, 0xfa, 0x7c, 0x4a,
	0xd0, 0xaf, 0xc3, 0x42, 0x87, 0x9f, 0x58, 0x7c, 0x3c, 0xa2, 0xb0, 0xcd, 0x77, 0xf8, 0x89, 0x39,
	0x1e, 0x7d, 0x8e, 0x70, 0xfd, 0x07, 0x1d, 0x73, 0x51, 0xcb, 0x5c, 0xac, 0x93, 0x60, 0x28, 0x59,
	0x01, 0x67, 0x31, 0x27, 0xc1, 0x89, 0x16, 0x67, 0xe8, 0x24, 0x22, 0x40, 0xc9, 0xc5, 0xa3, 0x07,
	0xf3, 0x22, 0xd2, 0x90, 0xe5, 0x1c, 0x27, 0x80, 0xde, 0x86, 0x6b, 0x89, 0xa5, 0xad, 0xb6, 0xdb,
	0x41, 0x03, 0x96, 0xef, 0xd7, 0xa3, 0x1e, 0x93, 0x54, 0xbf, 0xde, 0x50, 0xb7, 0x67, 0x5e, 0x89,
	0xed, 0xb7, 0xe1, 0x76, 0x98, 0xf1, 0x36, 0x2c, 0xc7, 0xf8, 0xf4, 0x02, 0xe4, 0x1e, 0x1f, 0x3c,
	0x6e, 0x56, 0xe6, 0xf4, 0x22, 0xcc, 0x37, 0xf7, 0x0f, 0x5b, 0xef, 0x57, 0x34, 0xbd, 0x04, 0x85,
	0xc6, 0xc1, 0xe3, 0xdd, 0xf7, 0x1e, 0x36, 0x5a, 0x95, 0x8c, 0xf1, 0x71, 0x16, 0x56, 0xa4, 0x9f,
	0xb2, 0x63, 0x26, 0x0c, 0xfc, 0xbf, 0x50, 0x78, 0x15, 0x42, 0xe1, 0xaf, 0x19, 0xd0, 0xa3, 0x56,
	0xf9, 0xef, 0x08, 0x03, 0xeb, 0x39, 0x61, 0x70, 0x4f, 0xf1, 0x16, 0x45, 0xf5, 0x97, 0x19, 0x02,
	0xff, 0xcc, 0xc0, 0x0d, 0x19, 0x78, 0x52, 0xad, 0x5d, 0x67, 0xc0, 0xfc, 0x07, 0x6d, 0x81, 0xe2,
	0x1e, 0xb3, 0x3b, 0x8c, 0xeb, 0xbb, 0x90, 0xb7, 0xe5, 0x58, 0xc2, 0x1d, 0x8f, 0xd6, 0xf4, 0x8f,
	0xea, 0x38, 0x68, 0x9d, 0x78, 0xcc, 0xa4, 0xaf, 0xc5, 0xb9, 0xd9, 0x75, 0x06, 0xcc, 0xf2, 0xec,
	0xa0, 0x4f, 0xb7, 0x9f, 0x82, 0x20, 0x1c, 0xda, 0x41, 0x5f, 0xdf, 0x80, 0x25, 0x4f, 0x5c, 0x6b,
	0xdc, 0xb1, 0x8f, 0x0c, 0x59, 0xc9, 0x50, 0x0a, 0x89, 0x92, 0x49, 0x14, 0x05, 0xb6, 0xcf, 0xbe,
	0xfa, 0xb6, 0x28, 0x9a, 0x02, 0x46, 0xcd, 0x0e, 0x51, 0x14, 0x48, 0x6a, 0x03, 0x89, 0xfa, 0x5d,
	0xa8, 0xb0, 0x67, 0xac, 0x3d, 0x0e, 0x98, 0x25, 0xe4, 0x0f, 0x43, 0x84, 0x0b, 0xe6, 0x32, 0xd1,
	0x77, 0x89, 0x2c, 0x96, 0x75, 0x46, 0x5d, 0xc6, 0x27, 0x02, 0xb1, 0xc4, 0x2e, 0x49, 0x22, 0xc9,
	0x33, 0x9e, 0x02, 0x4c, 0xd5, 0xd1, 0x01, 0xf2, 0x0d, 0xb3, 0xf9, 0xa0, 0x25, 0x30, 0x2d, 0x03,
	0xe0, 0x6f, 0x6b, 0xe7, 0xa1, 0x59, 0xd1, 0xc4, 0xdc, 0xd3, 0xc3, 0x1d, 0x31, 0x97, 0x11, 0xc8,
	0xef, 0x1f, 0x7c, 0xa7, 0x59, 0xc9, 0x0a, 0xea, 0x4e, 0xf3, 0xbd, 0x66, 0xab, 0x59, 0xc9, 0x09,
	0x2b, 0x34, 0xf6, 0xf6, 0x0f, 0x76, 0x2a, 0xf3, 0xc6, 0x27, 0x1a, 0x9d, 0xc4, 0x71, 0x08, 0xf5,
	0x77, 0x21, 0xdf, 0x97, 0x30, 0x92, 0x83, 0x6f, 0x9c, 0x01, 0xf1, 0xbd, 0x39, 0x93, 0x3e, 0xd2,
	0x6b, 0xb0, 0x10, 0xaa, 0x23, 0x61, 0xde, 0x9b, 0x33, 0x43, 0xc2, 0xb6, 0x01, 0xeb, 0x22, 0x0b,
	0x59, 0xe4, 0xd7, 0x02, 0x1f, 0xdf, 0x42, 0x03, 0x59, 0x9e, 0x7d, 0x32, 0x70, 0xed, 0x8e, 0xf1,
	0xaf, 0x2c, 0xdc, 0x8c, 0xad, 0x44, 0x89, 0x91, 0x3c, 0xe2, 0x65, 0xa6, 0xc7, 0x58, 0xce, 0xcb,
	0x26, 0x72, 0xde, 0x6d, 0x28, 0xd3, 0xe6, 0xc3, 0xd4, 0x87, 0x79, 0x71, 0x09, 0xa9, 0xfb, 0x94,
	0x00, 0xdf, 0x04, 0x9d, 0xd8, 0xec, 0x71, 0xd0, 0x77, 0x39, 0x8a, 0xc3, 0x2c, 0x59, 0xc1, 0x99,
	0x07, 0x72, 0x42, 0x0a, 0xad, 0xc3, 0x15, 0x95, 0x9b, 0x0d, 0x6d, 0x67, 0x40, 0x09, 0x73, 0x25,
	0xca, 0xde, 0x14, 0x13, 0xe9, 0xe9, 0x75, 0xe1, 0xec, 0xe9, 0xb5, 0x70, 0xf6, 0xf4, 0x7a, 0x15,
	0xe6, 0xbb, 0x2e, 0x6f, 0x33, 0x99, 0x41, 0x0b, 0x26, 0x0e, 0x44, 0x30, 0xa1, 0x50, 0x71, 0xaf,
	0x01, 0x2c, 0x42, 0x25, 0x41, 0x5c, 0x6b, 0x94, 0xc4, 0xbb, 0x78, 0x9e, 0xc4, 0xfb, 0x3b, 0x8d,
	0x6a, 0x90, 0x84, 0xe9, 0xf5, 0xaf, 0xc7, 0x9c, 0xf2, 0xd6, 0x0c, 0xa7, 0x54, 0x5c, 0x25, 0xe2,
	0x95, 0x5f, 0x9b, 0xa4, 0x91, 0x8c, 0x9a, 0xb5, 0xd3, 0x9d, 0x7a, 0x2e, 0xcc, 0x1b, 0xdb, 0x1b,
	0xf0, 0x46, 0xd2, 0x65, 0x39, 0xae, 0x32, 0xf1, 0xd9, 0x5f, 0x85, 0xdd, 0xd9, 0xe8, 0x46, 0x2e,
	0xf0, 0xd8, 0x58, 0x83, 0x45, 0x67, 0xd4, 0x61, 0xcf, 0x94, 0x03, 0x03, 0x24, 0xe9, 0x94, 0x83,
	0x60, 0x46, 0x43, 0xe3, 0x37, 0x39, 0x0c, 0x30, 0x93, 0x89, 0xc4, 0x25, 0xae, 0x7a, 0x0e, 0x1f,
	0xda, 0x47, 0x03, 0x16, 0x62, 0xdd, 0x8c, 0x61, 0xfd, 0x25, 0xf5, 0x64, 0x48, 0xff, 0xaa, 0x9e,
	0x80, 0xfc, 0x5a, 0xd8, 0x38, 0x90, 0x17, 0xac, 0xbd, 0x39, 0x6a, 0x1d, 0xd4, 0x7e, 0x92, 0x85,
	0xfc, 0x25, 0x84, 0xf2, 0x0d, 0x28, 0x72, 0xb9, 0xd7, 0xc8, 0x45, 0x09, 0x09, 0xa7, 0x34, 0x50,
	0x56, 0x81, 0x82, 0x5d, 0x7a, 0xf6, 0x3c, 0xde, 0xd8, 0x91, 0x22, 0x5c, 0xfb, 0x1b, 0xb0, 0xc2,
	0xd9, 0xd0, 0x0d, 0x58, 0x34, 0x9a, 0xf2, 0x33, 0xa3, 0xa9, 0x82, 0xcc, 0x91, 0x70, 0xda, 0x80,
	0x25, 0x12, 0x40, 0xcb, 0x63, 0xd4, 0x96, 0x90, 0x88, 0x1e, 0x20, 0xae, 0xf1, 0x3d, 0x27, 0xb0,
	0xbc, 0xb1, 0xdf, 0xb7, 0x5c, 0x4f, 0x3e, 0x24, 0x54, 0x0b, 0xeb, 0xd9, 0xcd, 0xa2, 0x59, 0xee,
	0x39, 0xc1, 0xe1, 0xd8, 0xef, 0x1f, 0x20, 0xf5, 0xc5, 0x6b, 0x9c, 0xed, 0xbb, 0x70, 0x47, 0xba,
	0x35, 0x41, 0xd4, 0x9e, 0xda, 0x33, 0xe1, 0xdc, 0x7f, 0xd1, 0x60, 0x75, 0x86, 0xe5, 0xc9, 0xc5,
	0xd7, 0x84, 0x19, 0xa5, 0x1c, 0x81, 0x9a, 0xbc, 0x6f, 0xef, 0xcd, 0x99, 0x04, 0xbf, 0xc0, 0xed,
	0x0e, 0x94, 0x89, 0x41, 0xb8, 0x80, 0x13, 0x5e, 0xba, 0xf7, 0xe6, 0xcc, 0x25, 0xa4, 0x3f, 0x40,
	0xf2, 0x79, 0xfc, 0x58, 0x18, 0xb8, 0x37, 0x29, 0x8e, 0xb0, 0xe8, 0x29, 0xf4, 0xa8, 0x32, 0xda,
	0xbe, 0x07, 0x9b, 0xb3, 0xf5, 0xc3, 0x6d, 0x4f, 0x14, 0xfc, 0x53, 0x06, 0xab, 0xf0, 0x27, 0x1f,
	0x8e, 0x6d, 0xff, 0xb2, 0x2e, 0xf1, 0xbe, 0x5c, 0x2c, 0xe2, 0x9b, 0x48, 0x78, 0xd8, 0x51, 0x93,
	0xeb, 0x7c, 0x2c, 0xb9, 0x5e, 0x87, 0x05, 0x36, 0xea, 0xc8, 0xa9, 0xbc, 0x9c, 0xca, 0xb3, 0x51,
	0x47, 0x4c, 0xdc, 0x82, 0x3c, 0x1e, 0x1e, 0x54, 0x3c, 0xab, 0xcb, 0xd2, 0x5c, 0xca, 0xf1, 0x55,
	0x48, 0x3b, 0xbe, 0x5e, 0xd8, 0xaf, 0x1e, 0xe5, 0x0a, 0xb9, 0xca, 0xbc, 0xe1, 0x60, 0x01, 0x1d,
	0x02, 0x3a, 0x69, 0xd6, 0x02, 0x69, 0x3d, 0x71, 0x13, 0x93, 0x70, 0x10, 0x1a, 0x28, 0xf6, 0xcc,
	0xaa, 0xf6, 0xc4, 0x36, 0x9e, 0x99, 0x74, 0x0e, 0xe3, 0xcf, 0xd4, 0xd9, 0x13, 0x1e, 0x74, 0x72,
	0x68, 0x07, 0xd3, 0x2e, 0xcc, 0xa9, 0x47, 0x46, 0x82, 0xbd, 0x9e, 0x56, 0xc8, 0x78, 0x82, 0x81,
	0xf9, 0xd3, 0x42, 0x86, 0x08, 0xb5, 0x3f, 0x68, 0x97, 0x92, 0xc3, 0x36, 0x60, 0x89, 0x3a, 0x81,
	0x94, 0x2e, 0xa8, 0x2e, 0x45, 0x22, 0xa5, 0x0b, 0xc5, 0x58, 0xb9, 0xf3, 0x24, 0x81, 0xb0, 0x1c,
	0x93, 0x79, 0xd9, 0x92, 0xba, 0x25, 0xa2, 0xff, 0x03, 0x3c, 0x92, 0xa3, 0x78, 0x5d, 0xdc, 0xc1,
	0x66, 0xfc, 0x36, 0x03, 0xb5, 0xe9, 0x23, 0xd7, 0x93, 0xf1, 0xd1, 0xd0, 0xed, 0x8c, 0xa7, 0x27,
	0xd1, 0x4b, 0x6e, 0xce, 0x52, 0x28, 0x44, 0x9a, 0xb3, 0x48, 0x39, 0xad, 0x39, 0x7b, 0x13, 0x8a,
	0x7e, 0xb8, 0xcd, 0xb0, 0x37, 0x3b, 0x21, 0xa4, 0xc4, 0x57, 0xfe, 0xb9, 0xf1, 0x75, 0xae, 0x97,
	0x90, 0x3f, 0x6a, 0x78, 0x5d, 0x4a, 0x00, 0xf6, 0xc5, 0x34, 0xf4, 0x12, 0x97, 0xd4, 0x5c, 0xe2,
	0x92, 0xfa, 0x28, 0x57, 0xc8, 0x56, 0x72, 0x66, 0xf2, 0xde, 0x7b, 0xff, 0x6f, 0x00, 0x95, 0xc9,
	0x7e, 0x9e, 0x30, 0x7e, 0xec, 0xb4, 0x99, 0xfe, 0x7d, 0xa8, 0xc4, 0x9f, 0x8b, 0xf5, 0x35, 0xa5,
	0x58, 0x4b, 0xbe, 0x80, 0xd7, 0xd6, 0x67, 0x33, 0x20, 0x2e, 0x46, 0xfe, 0xdf, 0x9f, 0x6e, 0x66,
	0x0a, 0x5a, 0x28, 0x3e, 0xfa, 0xa8, 0xaa, 0x8a, 0x4f, 0x79, 0x36, 0x56, 0xc5, 0xa7, 0xbd, 0xc7,
	0xc6, 0xc5, 0x47, 0x9f, 0x34, 0x55, 0xf1, 0x29, 0x8f, 0xb0, 0xaa, 0xf8, 0xb4, 0xd7, 0xd0, 0x89,
	0xf8, 0x16, 0x2c, 0x29, 0xef, 0x60, 0xfa, 0xcd, 0xa4, 0xe2, 0xd3, 0xa7, 0xc2, 0xda, 0xea, 0x8c,
	0xd9, 0x74, 0xa9, 0x93, 0xf7, 0x4a, 0x55, 0x6a, 0xfc, 0x55, 0x55, 0x95, 0x9a, 0x78, 0xe4, 0x9c,
	0x48, 0xfd, 0x2e, 0x94, 0xd5, 0xfe, 0xbf, 0xae, 0x7c, 0x98, 0x78, 0x89, 0xa9, 0xfd, 0xdf, 0xac,
	0xe9, 0x98, 0xe0, 0x1f, 0xc0, 0x72, 0xec, 0xe5, 0x49, 0x4f, 0x7e, 0xaa, 0x22, 0xbc, 0x36, 0x73,
	0x5e, 0x95, 0xbd, 0xa9, 0xbd, 0xa5, 0xe9, 0xdf, 0x86, 0x52, 0xb4, 0x57, 0xae, 0xdf, 0x88, 0x7e,
	0x1c, 0x6b, 0xf5, 0xd7, 0x6e, 0xa6, 0x4f, 0xa6, 0x63, 0x31, 0x6d, 0x2e, 0xaa, 0x58, 0x24, 0xba,
	0xe1, 0x2a, 0x16, 0xc9, 0x9e, 0xe4, 0x44, 0xf0, 0x07, 0x88, 0x45, 0xe4, 0xde, 0xa1, 0x62, 0x91,
	0xbc, 0x19, 0xa9, 0x58, 0xa4, 0x5c, 0x58, 0xa6, 0x58, 0xe8, 0x1e, 0x1e, 0xad, 0x89, 0xc2, 0x4f,
	0xbf, 0x75, 0x96, 0x1b, 0x41, 0xed, 0xf6, 0x73, 0xb8, 0x52, 0xb0, 0xff, 0x16, 0xc0, 0xb4, 0xfd,
	0xa4, 0xbf, 0x9e, 0xd6, 0x92, 0x42, 0xd9, 0xb5, 0xd9, 0xdd, 0xaa, 0x09, 0x38, 0x24, 0x0c, 0xab,
	0x10, 0x55, 0x98, 0x52, 0xea, 0xa9, 0xc2, 0xd4, 0xa2, 0x65, 0x22, 0xec, 0x7d, 0x34, 0xe1, 0xf4,
	0x1c, 0x54, 0x4d, 0x98, 0xa8, 0x27, 0x54, 0x13, 0x26, 0x8f, 0xcf, 0x08, 0xcc, 0x5d, 0x7c, 0x45,
	0x8a, 0xa5, 0x74, 0xdd, 0x48, 0x66, 0x9d, 0xf8, 0x01, 0x59, 0xdb, 0x38, 0x95, 0x47, 0x5d, 0x69,
	0xfb, 0xad, 0xef, 0x09, 0xee, 0x81, 0x7d, 0x54, 0x6f, 0xbb, 0xc3, 0x2d, 0xfc, 0xf9, 0x65, 0x97,
	0xf7, 0xb6, 0x50, 0x06, 0xfe, 0xf9, 0x68, 0xab, 0xe7, 0xd2, 0xd8, 0x3b, 0x3a, 0xca, 0x4b, 0xd2,
	0x57, 0xfe, 0x13, 0x00, 0x00, 0xff, 0xff, 0x9d, 0xa6, 0xe8, 0xfe, 0xd3, 0x24, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// OperationServiceClient is the client API for OperationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type OperationServiceClient interface {
	UserCreateBranch(ctx context.Context, in *UserCreateBranchRequest, opts ...grpc.CallOption) (*UserCreateBranchResponse, error)
	UserUpdateBranch(ctx context.Context, in *UserUpdateBranchRequest, opts ...grpc.CallOption) (*UserUpdateBranchResponse, error)
	UserDeleteBranch(ctx context.Context, in *UserDeleteBranchRequest, opts ...grpc.CallOption) (*UserDeleteBranchResponse, error)
	// UserCreateTag creates a new tag.
	UserCreateTag(ctx context.Context, in *UserCreateTagRequest, opts ...grpc.CallOption) (*UserCreateTagResponse, error)
	UserDeleteTag(ctx context.Context, in *UserDeleteTagRequest, opts ...grpc.CallOption) (*UserDeleteTagResponse, error)
	// UserMergeRef creates a merge commit and updates target_ref to point to that
	// new commit. The first parent of the merge commit (the main line) is taken
	// from first_parent_ref. The second parent is specified by its commit ID in source_sha.
	// If target_ref already exists it will be overwritten.
	UserMergeToRef(ctx context.Context, in *UserMergeToRefRequest, opts ...grpc.CallOption) (*UserMergeToRefResponse, error)
	// UserMergeBranch tries to merge the given commit into the target branch.
	// The merge commit is created with the given user as author/committer and
	// the given message.
	//
	// This RPC requires confirmation to make any user-visible changes to the
	// repository. The first request sent shall contain details about the
	// requested merge, which will result in a response with the created merge
	// commit ID. Only if a second message with `apply = true` is sent will the
	// merge be applied.
	UserMergeBranch(ctx context.Context, opts ...grpc.CallOption) (OperationService_UserMergeBranchClient, error)
	// UserFFBranch tries to perform a fast-forward merge of the given branch to
	// the given commit. If the merge is not a fast-forward merge, the request
	// will fail. The RPC will return an empty response in case updating the
	// reference fails e.g. because of a race.
	UserFFBranch(ctx context.Context, in *UserFFBranchRequest, opts ...grpc.CallOption) (*UserFFBranchResponse, error)
	// UserCherryPick tries to perform a cherry-pick of a given commit onto a
	// branch.
	UserCherryPick(ctx context.Context, in *UserCherryPickRequest, opts ...grpc.CallOption) (*UserCherryPickResponse, error)
	// UserCommitFiles builds a commit from a stream of actions and updates the target branch to point to it.
	// UserCommitFilesRequest with a UserCommitFilesRequestHeader must be sent as the first message of the stream.
	// Following that, a variable number of actions can be sent to build a new commit. Each action consists of
	// a header followed by content if used by the action.
	UserCommitFiles(ctx context.Context, opts ...grpc.CallOption) (OperationService_UserCommitFilesClient, error)
	// UserRebaseConfirmable rebases the given remote branch onto a target
	// branch. The remote branch may be part of another repository.
	//
	// This RPC requires confirmation to make any user-visible changes to the
	// repository. The first request sent shall contains details about the
	// requested rebase, which will result in a response with the created rebase
	// commit ID. Only if a second message with `apply = true` is sent will the
	// rebase be applied.
	UserRebaseConfirmable(ctx context.Context, opts ...grpc.CallOption) (OperationService_UserRebaseConfirmableClient, error)
	// UserRevert tries to perform a revert of a given commit onto a branch.
	UserRevert(ctx context.Context, in *UserRevertRequest, opts ...grpc.CallOption) (*UserRevertResponse, error)
	// UserSquash squashes a range of commits into a single commit.
	UserSquash(ctx context.Context, in *UserSquashRequest, opts ...grpc.CallOption) (*UserSquashResponse, error)
	// UserApplyPatch applies patches to a given branch.
	UserApplyPatch(ctx context.Context, opts ...grpc.CallOption) (OperationService_UserApplyPatchClient, error)
	// UserUpdateSubmodule updates a submodule to point to a new commit.
	UserUpdateSubmodule(ctx context.Context, in *UserUpdateSubmoduleRequest, opts ...grpc.CallOption) (*UserUpdateSubmoduleResponse, error)
}

type operationServiceClient struct {
	cc *grpc.ClientConn
}

func NewOperationServiceClient(cc *grpc.ClientConn) OperationServiceClient {
	return &operationServiceClient{cc}
}

func (c *operationServiceClient) UserCreateBranch(ctx context.Context, in *UserCreateBranchRequest, opts ...grpc.CallOption) (*UserCreateBranchResponse, error) {
	out := new(UserCreateBranchResponse)
	err := c.cc.Invoke(ctx, "/gitaly.OperationService/UserCreateBranch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operationServiceClient) UserUpdateBranch(ctx context.Context, in *UserUpdateBranchRequest, opts ...grpc.CallOption) (*UserUpdateBranchResponse, error) {
	out := new(UserUpdateBranchResponse)
	err := c.cc.Invoke(ctx, "/gitaly.OperationService/UserUpdateBranch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operationServiceClient) UserDeleteBranch(ctx context.Context, in *UserDeleteBranchRequest, opts ...grpc.CallOption) (*UserDeleteBranchResponse, error) {
	out := new(UserDeleteBranchResponse)
	err := c.cc.Invoke(ctx, "/gitaly.OperationService/UserDeleteBranch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operationServiceClient) UserCreateTag(ctx context.Context, in *UserCreateTagRequest, opts ...grpc.CallOption) (*UserCreateTagResponse, error) {
	out := new(UserCreateTagResponse)
	err := c.cc.Invoke(ctx, "/gitaly.OperationService/UserCreateTag", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operationServiceClient) UserDeleteTag(ctx context.Context, in *UserDeleteTagRequest, opts ...grpc.CallOption) (*UserDeleteTagResponse, error) {
	out := new(UserDeleteTagResponse)
	err := c.cc.Invoke(ctx, "/gitaly.OperationService/UserDeleteTag", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operationServiceClient) UserMergeToRef(ctx context.Context, in *UserMergeToRefRequest, opts ...grpc.CallOption) (*UserMergeToRefResponse, error) {
	out := new(UserMergeToRefResponse)
	err := c.cc.Invoke(ctx, "/gitaly.OperationService/UserMergeToRef", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operationServiceClient) UserMergeBranch(ctx context.Context, opts ...grpc.CallOption) (OperationService_UserMergeBranchClient, error) {
	stream, err := c.cc.NewStream(ctx, &_OperationService_serviceDesc.Streams[0], "/gitaly.OperationService/UserMergeBranch", opts...)
	if err != nil {
		return nil, err
	}
	x := &operationServiceUserMergeBranchClient{stream}
	return x, nil
}

type OperationService_UserMergeBranchClient interface {
	Send(*UserMergeBranchRequest) error
	Recv() (*UserMergeBranchResponse, error)
	grpc.ClientStream
}

type operationServiceUserMergeBranchClient struct {
	grpc.ClientStream
}

func (x *operationServiceUserMergeBranchClient) Send(m *UserMergeBranchRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *operationServiceUserMergeBranchClient) Recv() (*UserMergeBranchResponse, error) {
	m := new(UserMergeBranchResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *operationServiceClient) UserFFBranch(ctx context.Context, in *UserFFBranchRequest, opts ...grpc.CallOption) (*UserFFBranchResponse, error) {
	out := new(UserFFBranchResponse)
	err := c.cc.Invoke(ctx, "/gitaly.OperationService/UserFFBranch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operationServiceClient) UserCherryPick(ctx context.Context, in *UserCherryPickRequest, opts ...grpc.CallOption) (*UserCherryPickResponse, error) {
	out := new(UserCherryPickResponse)
	err := c.cc.Invoke(ctx, "/gitaly.OperationService/UserCherryPick", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operationServiceClient) UserCommitFiles(ctx context.Context, opts ...grpc.CallOption) (OperationService_UserCommitFilesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_OperationService_serviceDesc.Streams[1], "/gitaly.OperationService/UserCommitFiles", opts...)
	if err != nil {
		return nil, err
	}
	x := &operationServiceUserCommitFilesClient{stream}
	return x, nil
}

type OperationService_UserCommitFilesClient interface {
	Send(*UserCommitFilesRequest) error
	CloseAndRecv() (*UserCommitFilesResponse, error)
	grpc.ClientStream
}

type operationServiceUserCommitFilesClient struct {
	grpc.ClientStream
}

func (x *operationServiceUserCommitFilesClient) Send(m *UserCommitFilesRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *operationServiceUserCommitFilesClient) CloseAndRecv() (*UserCommitFilesResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(UserCommitFilesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *operationServiceClient) UserRebaseConfirmable(ctx context.Context, opts ...grpc.CallOption) (OperationService_UserRebaseConfirmableClient, error) {
	stream, err := c.cc.NewStream(ctx, &_OperationService_serviceDesc.Streams[2], "/gitaly.OperationService/UserRebaseConfirmable", opts...)
	if err != nil {
		return nil, err
	}
	x := &operationServiceUserRebaseConfirmableClient{stream}
	return x, nil
}

type OperationService_UserRebaseConfirmableClient interface {
	Send(*UserRebaseConfirmableRequest) error
	Recv() (*UserRebaseConfirmableResponse, error)
	grpc.ClientStream
}

type operationServiceUserRebaseConfirmableClient struct {
	grpc.ClientStream
}

func (x *operationServiceUserRebaseConfirmableClient) Send(m *UserRebaseConfirmableRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *operationServiceUserRebaseConfirmableClient) Recv() (*UserRebaseConfirmableResponse, error) {
	m := new(UserRebaseConfirmableResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *operationServiceClient) UserRevert(ctx context.Context, in *UserRevertRequest, opts ...grpc.CallOption) (*UserRevertResponse, error) {
	out := new(UserRevertResponse)
	err := c.cc.Invoke(ctx, "/gitaly.OperationService/UserRevert", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operationServiceClient) UserSquash(ctx context.Context, in *UserSquashRequest, opts ...grpc.CallOption) (*UserSquashResponse, error) {
	out := new(UserSquashResponse)
	err := c.cc.Invoke(ctx, "/gitaly.OperationService/UserSquash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *operationServiceClient) UserApplyPatch(ctx context.Context, opts ...grpc.CallOption) (OperationService_UserApplyPatchClient, error) {
	stream, err := c.cc.NewStream(ctx, &_OperationService_serviceDesc.Streams[3], "/gitaly.OperationService/UserApplyPatch", opts...)
	if err != nil {
		return nil, err
	}
	x := &operationServiceUserApplyPatchClient{stream}
	return x, nil
}

type OperationService_UserApplyPatchClient interface {
	Send(*UserApplyPatchRequest) error
	CloseAndRecv() (*UserApplyPatchResponse, error)
	grpc.ClientStream
}

type operationServiceUserApplyPatchClient struct {
	grpc.ClientStream
}

func (x *operationServiceUserApplyPatchClient) Send(m *UserApplyPatchRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *operationServiceUserApplyPatchClient) CloseAndRecv() (*UserApplyPatchResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(UserApplyPatchResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *operationServiceClient) UserUpdateSubmodule(ctx context.Context, in *UserUpdateSubmoduleRequest, opts ...grpc.CallOption) (*UserUpdateSubmoduleResponse, error) {
	out := new(UserUpdateSubmoduleResponse)
	err := c.cc.Invoke(ctx, "/gitaly.OperationService/UserUpdateSubmodule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OperationServiceServer is the server API for OperationService service.
type OperationServiceServer interface {
	UserCreateBranch(context.Context, *UserCreateBranchRequest) (*UserCreateBranchResponse, error)
	UserUpdateBranch(context.Context, *UserUpdateBranchRequest) (*UserUpdateBranchResponse, error)
	UserDeleteBranch(context.Context, *UserDeleteBranchRequest) (*UserDeleteBranchResponse, error)
	// UserCreateTag creates a new tag.
	UserCreateTag(context.Context, *UserCreateTagRequest) (*UserCreateTagResponse, error)
	UserDeleteTag(context.Context, *UserDeleteTagRequest) (*UserDeleteTagResponse, error)
	// UserMergeRef creates a merge commit and updates target_ref to point to that
	// new commit. The first parent of the merge commit (the main line) is taken
	// from first_parent_ref. The second parent is specified by its commit ID in source_sha.
	// If target_ref already exists it will be overwritten.
	UserMergeToRef(context.Context, *UserMergeToRefRequest) (*UserMergeToRefResponse, error)
	// UserMergeBranch tries to merge the given commit into the target branch.
	// The merge commit is created with the given user as author/committer and
	// the given message.
	//
	// This RPC requires confirmation to make any user-visible changes to the
	// repository. The first request sent shall contain details about the
	// requested merge, which will result in a response with the created merge
	// commit ID. Only if a second message with `apply = true` is sent will the
	// merge be applied.
	UserMergeBranch(OperationService_UserMergeBranchServer) error
	// UserFFBranch tries to perform a fast-forward merge of the given branch to
	// the given commit. If the merge is not a fast-forward merge, the request
	// will fail. The RPC will return an empty response in case updating the
	// reference fails e.g. because of a race.
	UserFFBranch(context.Context, *UserFFBranchRequest) (*UserFFBranchResponse, error)
	// UserCherryPick tries to perform a cherry-pick of a given commit onto a
	// branch.
	UserCherryPick(context.Context, *UserCherryPickRequest) (*UserCherryPickResponse, error)
	// UserCommitFiles builds a commit from a stream of actions and updates the target branch to point to it.
	// UserCommitFilesRequest with a UserCommitFilesRequestHeader must be sent as the first message of the stream.
	// Following that, a variable number of actions can be sent to build a new commit. Each action consists of
	// a header followed by content if used by the action.
	UserCommitFiles(OperationService_UserCommitFilesServer) error
	// UserRebaseConfirmable rebases the given remote branch onto a target
	// branch. The remote branch may be part of another repository.
	//
	// This RPC requires confirmation to make any user-visible changes to the
	// repository. The first request sent shall contains details about the
	// requested rebase, which will result in a response with the created rebase
	// commit ID. Only if a second message with `apply = true` is sent will the
	// rebase be applied.
	UserRebaseConfirmable(OperationService_UserRebaseConfirmableServer) error
	// UserRevert tries to perform a revert of a given commit onto a branch.
	UserRevert(context.Context, *UserRevertRequest) (*UserRevertResponse, error)
	// UserSquash squashes a range of commits into a single commit.
	UserSquash(context.Context, *UserSquashRequest) (*UserSquashResponse, error)
	// UserApplyPatch applies patches to a given branch.
	UserApplyPatch(OperationService_UserApplyPatchServer) error
	// UserUpdateSubmodule updates a submodule to point to a new commit.
	UserUpdateSubmodule(context.Context, *UserUpdateSubmoduleRequest) (*UserUpdateSubmoduleResponse, error)
}

// UnimplementedOperationServiceServer can be embedded to have forward compatible implementations.
type UnimplementedOperationServiceServer struct {
}

func (*UnimplementedOperationServiceServer) UserCreateBranch(ctx context.Context, req *UserCreateBranchRequest) (*UserCreateBranchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserCreateBranch not implemented")
}
func (*UnimplementedOperationServiceServer) UserUpdateBranch(ctx context.Context, req *UserUpdateBranchRequest) (*UserUpdateBranchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserUpdateBranch not implemented")
}
func (*UnimplementedOperationServiceServer) UserDeleteBranch(ctx context.Context, req *UserDeleteBranchRequest) (*UserDeleteBranchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserDeleteBranch not implemented")
}
func (*UnimplementedOperationServiceServer) UserCreateTag(ctx context.Context, req *UserCreateTagRequest) (*UserCreateTagResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserCreateTag not implemented")
}
func (*UnimplementedOperationServiceServer) UserDeleteTag(ctx context.Context, req *UserDeleteTagRequest) (*UserDeleteTagResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserDeleteTag not implemented")
}
func (*UnimplementedOperationServiceServer) UserMergeToRef(ctx context.Context, req *UserMergeToRefRequest) (*UserMergeToRefResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserMergeToRef not implemented")
}
func (*UnimplementedOperationServiceServer) UserMergeBranch(srv OperationService_UserMergeBranchServer) error {
	return status.Errorf(codes.Unimplemented, "method UserMergeBranch not implemented")
}
func (*UnimplementedOperationServiceServer) UserFFBranch(ctx context.Context, req *UserFFBranchRequest) (*UserFFBranchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserFFBranch not implemented")
}
func (*UnimplementedOperationServiceServer) UserCherryPick(ctx context.Context, req *UserCherryPickRequest) (*UserCherryPickResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserCherryPick not implemented")
}
func (*UnimplementedOperationServiceServer) UserCommitFiles(srv OperationService_UserCommitFilesServer) error {
	return status.Errorf(codes.Unimplemented, "method UserCommitFiles not implemented")
}
func (*UnimplementedOperationServiceServer) UserRebaseConfirmable(srv OperationService_UserRebaseConfirmableServer) error {
	return status.Errorf(codes.Unimplemented, "method UserRebaseConfirmable not implemented")
}
func (*UnimplementedOperationServiceServer) UserRevert(ctx context.Context, req *UserRevertRequest) (*UserRevertResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserRevert not implemented")
}
func (*UnimplementedOperationServiceServer) UserSquash(ctx context.Context, req *UserSquashRequest) (*UserSquashResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserSquash not implemented")
}
func (*UnimplementedOperationServiceServer) UserApplyPatch(srv OperationService_UserApplyPatchServer) error {
	return status.Errorf(codes.Unimplemented, "method UserApplyPatch not implemented")
}
func (*UnimplementedOperationServiceServer) UserUpdateSubmodule(ctx context.Context, req *UserUpdateSubmoduleRequest) (*UserUpdateSubmoduleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserUpdateSubmodule not implemented")
}

func RegisterOperationServiceServer(s *grpc.Server, srv OperationServiceServer) {
	s.RegisterService(&_OperationService_serviceDesc, srv)
}

func _OperationService_UserCreateBranch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserCreateBranchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperationServiceServer).UserCreateBranch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitaly.OperationService/UserCreateBranch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperationServiceServer).UserCreateBranch(ctx, req.(*UserCreateBranchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperationService_UserUpdateBranch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserUpdateBranchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperationServiceServer).UserUpdateBranch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitaly.OperationService/UserUpdateBranch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperationServiceServer).UserUpdateBranch(ctx, req.(*UserUpdateBranchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperationService_UserDeleteBranch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserDeleteBranchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperationServiceServer).UserDeleteBranch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitaly.OperationService/UserDeleteBranch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperationServiceServer).UserDeleteBranch(ctx, req.(*UserDeleteBranchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperationService_UserCreateTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserCreateTagRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperationServiceServer).UserCreateTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitaly.OperationService/UserCreateTag",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperationServiceServer).UserCreateTag(ctx, req.(*UserCreateTagRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperationService_UserDeleteTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserDeleteTagRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperationServiceServer).UserDeleteTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitaly.OperationService/UserDeleteTag",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperationServiceServer).UserDeleteTag(ctx, req.(*UserDeleteTagRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperationService_UserMergeToRef_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserMergeToRefRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperationServiceServer).UserMergeToRef(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitaly.OperationService/UserMergeToRef",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperationServiceServer).UserMergeToRef(ctx, req.(*UserMergeToRefRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperationService_UserMergeBranch_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(OperationServiceServer).UserMergeBranch(&operationServiceUserMergeBranchServer{stream})
}

type OperationService_UserMergeBranchServer interface {
	Send(*UserMergeBranchResponse) error
	Recv() (*UserMergeBranchRequest, error)
	grpc.ServerStream
}

type operationServiceUserMergeBranchServer struct {
	grpc.ServerStream
}

func (x *operationServiceUserMergeBranchServer) Send(m *UserMergeBranchResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *operationServiceUserMergeBranchServer) Recv() (*UserMergeBranchRequest, error) {
	m := new(UserMergeBranchRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _OperationService_UserFFBranch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserFFBranchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperationServiceServer).UserFFBranch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitaly.OperationService/UserFFBranch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperationServiceServer).UserFFBranch(ctx, req.(*UserFFBranchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperationService_UserCherryPick_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserCherryPickRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperationServiceServer).UserCherryPick(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitaly.OperationService/UserCherryPick",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperationServiceServer).UserCherryPick(ctx, req.(*UserCherryPickRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperationService_UserCommitFiles_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(OperationServiceServer).UserCommitFiles(&operationServiceUserCommitFilesServer{stream})
}

type OperationService_UserCommitFilesServer interface {
	SendAndClose(*UserCommitFilesResponse) error
	Recv() (*UserCommitFilesRequest, error)
	grpc.ServerStream
}

type operationServiceUserCommitFilesServer struct {
	grpc.ServerStream
}

func (x *operationServiceUserCommitFilesServer) SendAndClose(m *UserCommitFilesResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *operationServiceUserCommitFilesServer) Recv() (*UserCommitFilesRequest, error) {
	m := new(UserCommitFilesRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _OperationService_UserRebaseConfirmable_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(OperationServiceServer).UserRebaseConfirmable(&operationServiceUserRebaseConfirmableServer{stream})
}

type OperationService_UserRebaseConfirmableServer interface {
	Send(*UserRebaseConfirmableResponse) error
	Recv() (*UserRebaseConfirmableRequest, error)
	grpc.ServerStream
}

type operationServiceUserRebaseConfirmableServer struct {
	grpc.ServerStream
}

func (x *operationServiceUserRebaseConfirmableServer) Send(m *UserRebaseConfirmableResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *operationServiceUserRebaseConfirmableServer) Recv() (*UserRebaseConfirmableRequest, error) {
	m := new(UserRebaseConfirmableRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _OperationService_UserRevert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRevertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperationServiceServer).UserRevert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitaly.OperationService/UserRevert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperationServiceServer).UserRevert(ctx, req.(*UserRevertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperationService_UserSquash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserSquashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperationServiceServer).UserSquash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitaly.OperationService/UserSquash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperationServiceServer).UserSquash(ctx, req.(*UserSquashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OperationService_UserApplyPatch_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(OperationServiceServer).UserApplyPatch(&operationServiceUserApplyPatchServer{stream})
}

type OperationService_UserApplyPatchServer interface {
	SendAndClose(*UserApplyPatchResponse) error
	Recv() (*UserApplyPatchRequest, error)
	grpc.ServerStream
}

type operationServiceUserApplyPatchServer struct {
	grpc.ServerStream
}

func (x *operationServiceUserApplyPatchServer) SendAndClose(m *UserApplyPatchResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *operationServiceUserApplyPatchServer) Recv() (*UserApplyPatchRequest, error) {
	m := new(UserApplyPatchRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _OperationService_UserUpdateSubmodule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserUpdateSubmoduleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OperationServiceServer).UserUpdateSubmodule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitaly.OperationService/UserUpdateSubmodule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OperationServiceServer).UserUpdateSubmodule(ctx, req.(*UserUpdateSubmoduleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _OperationService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "gitaly.OperationService",
	HandlerType: (*OperationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UserCreateBranch",
			Handler:    _OperationService_UserCreateBranch_Handler,
		},
		{
			MethodName: "UserUpdateBranch",
			Handler:    _OperationService_UserUpdateBranch_Handler,
		},
		{
			MethodName: "UserDeleteBranch",
			Handler:    _OperationService_UserDeleteBranch_Handler,
		},
		{
			MethodName: "UserCreateTag",
			Handler:    _OperationService_UserCreateTag_Handler,
		},
		{
			MethodName: "UserDeleteTag",
			Handler:    _OperationService_UserDeleteTag_Handler,
		},
		{
			MethodName: "UserMergeToRef",
			Handler:    _OperationService_UserMergeToRef_Handler,
		},
		{
			MethodName: "UserFFBranch",
			Handler:    _OperationService_UserFFBranch_Handler,
		},
		{
			MethodName: "UserCherryPick",
			Handler:    _OperationService_UserCherryPick_Handler,
		},
		{
			MethodName: "UserRevert",
			Handler:    _OperationService_UserRevert_Handler,
		},
		{
			MethodName: "UserSquash",
			Handler:    _OperationService_UserSquash_Handler,
		},
		{
			MethodName: "UserUpdateSubmodule",
			Handler:    _OperationService_UserUpdateSubmodule_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "UserMergeBranch",
			Handler:       _OperationService_UserMergeBranch_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "UserCommitFiles",
			Handler:       _OperationService_UserCommitFiles_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "UserRebaseConfirmable",
			Handler:       _OperationService_UserRebaseConfirmable_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "UserApplyPatch",
			Handler:       _OperationService_UserApplyPatch_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "operations.proto",
}
