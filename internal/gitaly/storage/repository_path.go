package storage

import (
	"crypto/sha256"
	"fmt"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
)

var (
	// PraefectRootPathPrefix is the root directory for all git repositories.
	PraefectRootPathPrefix = "@cluster"
	// praefectPoolPathPrefix is the prefix directory where Praefect places object pools.
	praefectPoolPathPrefix = filepath.Join(PraefectRootPathPrefix, "pools")
	// praefectBlobOffloadPathPrefix is the prefix directory where Praefect places offloaded blob packfiles.
	praefectBlobOffloadPathPrefix = filepath.Join(PraefectRootPathPrefix, "blob_offloads")
	// praefectRepositoryPathPrefix is the prefix directory where Praefect places repositories.
	praefectRepositoryPathPrefix = filepath.Join(PraefectRootPathPrefix, "repositories")
	// prafectPoolDirRegexp is used to validate object pool directory structure and name as generated by Praefect.
	praefectPoolDirRegexp = regexp.MustCompile(praefectPoolPathPrefix + `/[0-9a-f]{2}/[0-9a-f]{2}/[0-9]+$`)
	// railsPoolDirRegexp is used to validate object pool directory structure and name as generated by Rails.
	railsPoolDirRegexp = regexp.MustCompile(`@pools/([0-9a-f]{2})/([0-9a-f]{2})/([0-9a-f]{64})\.git$`)
)

// IsRailsPoolRepository returns whether the repository is a pool repository generated by Rails.
func IsRailsPoolRepository(repo Repository) bool {
	matches := railsPoolDirRegexp.FindStringSubmatch(repo.GetRelativePath())
	if matches == nil || !strings.HasPrefix(matches[3], matches[1]+matches[2]) {
		return false
	}

	return true
}

// IsPraefectPoolRepository returns whether the repository is a Praefect generated object pool repository.
func IsPraefectPoolRepository(repo Repository) bool {
	return praefectPoolDirRegexp.MatchString(repo.GetRelativePath())
}

// IsPoolRepository returns whether the repository is an object pool.
func IsPoolRepository(repo Repository) bool {
	return IsRailsPoolRepository(repo) || IsPraefectPoolRepository(repo)
}

// BlobOffloadPath returns the path where blobs are offloaded if some blobs are offloaded. It returns an
// empty string if no blobs are offloaded. praefectBlobOffloadPathPrefix should be in one of the
// GitAlternateObjectDirectories of the repo if some blobs are offloaded.
func BlobOffloadPath(repo Repository) string {
	for _, s := range repo.GetGitAlternateObjectDirectories() {
		if strings.HasPrefix(s, praefectBlobOffloadPathPrefix) {
			return s
		}
	}
	return ""
}

// DeriveReplicaPath derives a repository's disk storage path from its repository ID. The repository ID
// is hashed with SHA256 and the first four hex digits of the hash are used as the two subdirectories to
// ensure even distribution into subdirectories. The format is @cluster/repositories/ab/cd/<repository-id>.
func DeriveReplicaPath(repositoryID int64) string {
	return deriveDiskPath(praefectRepositoryPathPrefix, repositoryID)
}

// DerivePoolPath derives an object pools's disk storage path from its repository ID. The repository ID
// is hashed with SHA256 and the first four hex digits of the hash are used as the two subdirectories to
// ensure even distribution into subdirectories. The format is @cluster/pools/ab/cd/<repository-id>. The pools
// have a different directory prefix from other repositories so Gitaly can identify them in OptimizeRepository
// and avoid pruning them.
func DerivePoolPath(repositoryID int64) string {
	return deriveDiskPath(praefectPoolPathPrefix, repositoryID)
}

// DeriveBlobOffloadPath derives a blob offload's disk storage path from its repository ID. The repository ID
// is hashed with SHA256 and the first four hex digits of the hash are used as the two subdirectories to
// ensure even distribution into subdirectories. The format is @cluster/blob_offloads/ab/cd/<repository-id>.
// The blob offload packfiles are not full repository. They only contain packfiles. They are separated from the
// other repos so they can more easily be stored on separated cheap storage, like HDDs. They are accessed using
// the Git alternates mechanism.
func DeriveBlobOffloadPath(repositoryID int64) string {
	return deriveDiskPath(praefectBlobOffloadPathPrefix, repositoryID)
}

func deriveDiskPath(prefixDir string, repositoryID int64) string {
	hasher := sha256.New()
	// String representation of the ID is used to make it easier to derive the replica paths with
	// external tools. The error is ignored as the hash.Hash interface is documented to never return
	// an error.
	hasher.Write([]byte(strconv.FormatInt(repositoryID, 10)))
	hash := hasher.Sum(nil)
	return filepath.Join(prefixDir, fmt.Sprintf("%x/%x/%d", hash[0:1], hash[1:2], repositoryID))
}
